Comparing dispersal, environmental and mid-domain effects on species distribution
============================

`r rm(list=ls())`

##### By CSDambros

>html updated at `r as.character(Sys.time())`

### Methods

#### Study site
 
  The study was conducted in the whole area recognized as the Atlantic forest biome (Fig. 1). This biome encompasses an extent of 102,012 km², but today representing only 7.9% of its original forest cover. It has several vegetation types such as rainforests, mixed (Araucarian) moist forests, semideciduous forests, dry forests and upland grasslands. Rainforests tend to occur near the coast and semideciduous and dry forests far from coast; mixed forests are common in the south of AF (SOS Mata Atlântica 2007). AF shows moist tropical and subtropical climates, without well-defined dry season, and annual mean temperatures above 15ºC (Leite, 2002). 


```{r Loading packages and functions, results='hide',message=FALSE,echo=FALSE,warning=FALSE}

require(raster)
require(rgdal)
require(maptools)
require(vegan)
require(xtable)

source("anetwork.R")
source("MidD.R")
source("simunetwork.R")

Custom.Palette<- colorRampPalette(colors=c('lightblue','yellow','red'),bias=1,space='rgb')
color.select<-function(x){Custom.Palette(101)[1+round(((x-min(x))/diff(range(x)))*100)]}

op<-par(no.readonly=TRUE)
```

```{r Importing maps, results="hide",message=FALSE,echo=FALSE,warning=FALSE}

#The maps must be in a folder called "Shapefiles/" before running the code

folder<-"Shapefiles/"

brazil<-readShapeSpatial(paste(folder,"BR_Contorno.shp",sep=""))
biomes<-readShapeSpatial(paste(folder,"bioma.shp",sep=""))

```

#### Data collection

  We compiled a database based on the literature in which diverse authors have sampled small mammals along the AF (Appendix S1 in Supporting Information). We have used Google @ search tool for sampling articles, and the main keywords used in combination were “small mammal”, “marsupial”, “rodent”, “community”, “composition”, “richness”, “diversity”, and “Atlantic Forest”. Unpublished data sampled by NCC was also included (Appendix S1). There was some variation in the area covered by each surveyed study (see Appendix S1), but we have established a minimum of sampling effort for a given article to be accepted in our database: at least 1000 trap-nights, 6 months of field work, and use of wire type and/or Sherman live-traps installed on the ground or understory level of the forest. Besides that, and for independence assumptions, we have chosen surveyed areas distant at least 10 km from each other; most of the field surveys available in the literature sampled only one geographical location under this condition. From each selected survey, we obtained local species composition and abundance data when available. 

  Data on conservation were taken directly from information available on the articles consulted, and classified as categories of forest conservation (degrees 1 to 5), where primary conserved forest means 5 and disturbed secondary forest, including with clearings, means 1. Physiognomy data were taken either from information available on the area descriptions and from general sources such as (Veloso et al., 1991). We compiled the 19 environmental variables available in Bioclim (www.worldclim.org/bioclim) in a scale of 2.5 arc minutes: annual mean temperature (1), mean diurnal range (2), isothermality (3), temperature seasonality (4), maximum and minimum temperature of the warmest and coldest months (5 and 6), temperature annual range (7), mean temperature of the wettest, driest, warmest and coldest quarters (8-11), annual precipitation (12), precipitation of the wettest and driest months (13 and 14), precipitation seasonality (15), and precipitation of the wettest, direst, warmest and coldest quarters (16-19).  


```{r Importing data,message=FALSE,echo=FALSE,warning=FALSE}

mammal.data=read.csv('NC5.csv')# Data from each locality

```

```{r Importing environmental layers from worldclim, results="hide",message=FALSE,echo=FALSE,warning=FALSE}

wclim <- raster::getData("worldclim", var="bio", res=2.5, path="")
wclim.clipped<-crop(wclim,extent(-70,-30,-35,5))
#rm(wclim)


```

#### Analysis

  The environmental predictor variables were used as predictors of the species diversity and included in simulation models (see below). Most of the 19 WorldClim variables are correlated to each other, so we grouped these variables in two Principal Component Axes (PCA1 and PCA2) (But see Supplementary material S4 for individual comparisons). We standardized all the variables previously to the analyses. We preferred to use the described environmental variables as predictors and excluded the highly correlated variables of latitude and longitude. We used them to calculate the pairwise distance among sampling units and the linear distance of each sampling site to the coast.


```{r Transforming data and extract variables, results="hide",message=FALSE,echo=FALSE,warning=FALSE}

### Calculate the distance from the coast

poly<-(brazil@polygons)[[1]]@Polygons

LAT.coast<-unlist(lapply(poly,function(x){x@coords[,2]}))
LONG.coast<-unlist(lapply(poly,function(x){x@coords[,1]}))
long.chui<--(53+22/60+25/3600)

LONG.coast.east<-LONG.coast[LONG.coast>long.chui]
LAT.coast.east<-LAT.coast[LONG.coast>long.chui]

LONG.matrix.east<-t(matrix(LONG.coast.east,nrow=length(LONG.coast.east),ncol=length(mammal.data$Lat)))
LAT.matrix.east<-t(matrix(LAT.coast.east,nrow=length(LAT.coast.east),ncol=length(mammal.data$Lat)))

Longitude.matrix<-matrix(mammal.data$Long,nrow=length(mammal.data$Lat),ncol=length(LONG.coast.east))
Latitude.matrix<-matrix(mammal.data$Lat,nrow=length(mammal.data$Lat),ncol=length(LONG.coast.east))

LONG.diff<-LONG.matrix.east-Longitude.matrix
LAT.diff<-LAT.matrix.east-Latitude.matrix

Distance.coast.matrix<-sqrt(LONG.diff^2+LAT.diff^2)
mammal.data$Distance.coast<-apply(Distance.coast.matrix,1,min)

mammal.data$Long.closest<-apply(Distance.coast.matrix,1,function(x){LONG.coast.east[x==min(x)]})
mammal.data$Lat.closest<-apply(Distance.coast.matrix,1,function(x){LAT.coast.east[x==min(x)]})

#Grouping the latitude and longitude in 2x2 degrees (create new variables in the dataframe)
mammal.data$Long2<-floor(mammal.data$Long/2)*2+1
mammal.data$Lat2<-floor(mammal.data$Lat/2)*2+1

Longitude.matrix2<-matrix(mammal.data$Long2,nrow=length(mammal.data$Lat2),ncol=length(LONG.coast.east))
Latitude.matrix2<-matrix(mammal.data$Lat2,nrow=length(mammal.data$Lat2),ncol=length(LONG.coast.east))

LONG.diff2<-LONG.matrix.east-Longitude.matrix2
LAT.diff2<-LAT.matrix.east-Latitude.matrix2

Distance.coast.matrix2<-sqrt(LONG.diff2^2+LAT.diff2^2)
mammal.data$Distance.coast2<-apply(Distance.coast.matrix2,1,min)

mammal.data$Long.closest2<-apply(Distance.coast.matrix2,1,function(x){LONG.coast.east[x==min(x)]})
mammal.data$Lat.closest2<-apply(Distance.coast.matrix2,1,function(x){LAT.coast.east[x==min(x)]})

rm(Distance.coast.matrix,LAT.diff,LONG.diff,Longitude.matrix,Latitude.matrix,
   LONG.matrix.east,LAT.matrix.east,LONG.coast.east,LAT.coast.east,LAT.coast,LONG.coast,
   long.chui,poly,Distance.coast.matrix2,LAT.diff2,LONG.diff2,Longitude.matrix2,Latitude.matrix2)

attach(mammal.data)

#mammal.short.PA<-tapply(rep(1,length(LOCALIDADE)),list(LOCALIDADE,ESPECIE),sum)
#mammal.short.PA[is.na(mammal.short.PA)]<-0

#head(mammal.data)

```


```{r Creating_2x2_degrees_for_the_whole_AF,results='hide',message=FALSE,echo=FALSE,warning=FALSE}

AF.Long<-unlist(lapply((biomes[6,]@polygons)[[1]]@Polygons,function(x)x@coords[,1]))
AF.Lat<-unlist(lapply((biomes[6,]@polygons)[[1]]@Polygons,function(x)x@coords[,2]))

AF.Lat2<-ceiling(c(AF.Lat,Lat)/2)*2-1
AF.Long2<-ceiling(c(AF.Long,Long)/2)*2-1

#Create a dataframe with the unique locations representing the AF (the point 53 is an isolated island))
environment.AF.2d<-unique(data.frame(AF.Long2=AF.Long2,AF.Lat2=AF.Lat2))

```

  We analyzed the data using the original local sampling units and grouping the original data points in 26 2x2 degrees quadrants (Fig. 1). Most localities were surveyed by a single study, then most of the sampling points represent a single study (see data collection). We used the number of species encountered in each locality (S), and the similarity in species composition as response variables.
  We assessed the similarity in species composition by calculating the Jaccard similarity index among all pairs of samples. The matrix of similarities was summarized using a Principal Coordinates Analysis (PCoA). We used only the first two ordination axes because all axes in higher dimensions captured alone less than 10% of the variation from the similarity matrix.


``` {r Summarizing local environmental data, results='hide',echo=FALSE,message=FALSE,warning=FALSE}

species.ab.loc<-tapply(rep(1,length(Lat)),list(paste(Long,Lat),ESPECIE),sum)
species.ab.loc[is.na(species.ab.loc)]<-0

species.loc <- species.ab.loc
species.loc[species.loc>0]<-1

environment<-data.frame(unique(cbind(Long,Lat)))
environment<-environment[order(factor(paste(environment[,1],environment[,2]))),]

environment$dist.coast<-tapply(as.numeric(Distance.coast),paste(Long,Lat),mean)
environment$conservation<-tapply(as.numeric(CONSERVACAO),paste(Long,Lat),mean)
environment$vegetation<-tapply(as.numeric(FISIONOMIA),paste(Long,Lat),mean)

###

environment[paste("bio",1:19,sep="")]<-NA

#Take the mean climatic values of four points around the observed area

for(i in 1:nrow(environment)){
  temp.clim<-extract(wclim.clipped,extent(environment[i,1]-.05,environment[i,1]+.05,environment[i,2]-.05,environment[i,2]+.05))
  environment[i,paste("bio",1:19,sep="")]<-colMeans(temp.clim,na.rm=TRUE)}

environment[,paste("PCA.wclim.",1:3,sep="")]<-prcomp(decostand(environment[,paste("bio",1:19,sep="")],"standardize"))$x[,1:3]

# Creating observed statistics

environment$rich<-rowSums(species.loc)
similarity.jac.loc<-vegdist(species.loc,"jaccard")
environment[,paste("pcoa.jac.",1:3,sep="")]<-cmdscale(similarity.jac.loc,k=3)

environment<-data.frame(environment,std=decostand(environment,"standardize"))

geodist.loc<-dist(environment[,c("Lat","Long")])
envdist.loc<-dist(environment[grep("std",colnames(environment))][3:24])

```

```{r Summarizing environmental data for each quadrant, message=FALSE,results='hide',echo=FALSE,warning=FALSE}

species.2d<-tapply(rep(1,length(Lat2)),list(paste(Long2,Lat2),ESPECIE),sum)
species.2d[is.na(species.2d)]<-0
species.2d[species.2d>0]<-1

environment.2d<-data.frame(unique(cbind(Long2,Lat2)))
environment.2d<-environment.2d[order(factor(paste(environment.2d[,1],environment.2d[,2]))),]

environment.2d$dist.coast<-tapply(as.numeric(Distance.coast2),paste(Long2,Lat2),mean)
environment.2d$conservation<-tapply(as.numeric(CONSERVACAO),paste(Long2,Lat2),mean)
environment.2d$vegetation<-tapply(as.numeric(FISIONOMIA),paste(Long2,Lat2),mean)

# r extracting environmental data from worldclim layers, results="hide"}

environment.2d[paste("bio",1:19,sep="")]<-NA

for(i in 1:nrow(environment.2d)){
  temp.clim<-extract(wclim.clipped,extent(environment.2d[i,1]-1,environment.2d[i,1]+1,environment.2d[i,2]-1,environment.2d[i,2]+1))
  environment.2d[i,paste("bio",1:19,sep="")]<-colMeans(temp.clim,na.rm=TRUE)}

environment.2d[,paste("PCA.wclim.",1:3,sep="")]<-prcomp(decostand(environment.2d[,paste("bio",1:19,sep="")],"standardize"))$x[,1:3]


# Creating observed statistics

environment.2d$rich<-rowSums(species.2d)
similarity.jac<-vegdist(species.2d,"jaccard")
environment.2d[,paste("pcoa.jac.",1:3,sep="")]<-cmdscale(similarity.jac,k=3)

#plot(pcoa.jac.1~Lat2,data=environment.2d)

environment.2d<-data.frame(environment.2d,std=decostand(environment.2d,"standardize"))

environment.2d$matchin.AF.2d<-match(paste(environment.2d[,1],environment.2d[,2]),paste(environment.AF.2d[,1],environment.AF.2d[,2]))

geodist.2d<-dist(environment.2d[,c("Lat2","Long2")])
envdist.2d<-dist(environment.2d[grep("std",colnames(environment.2d))][3:24])

```


#### Fig. 1. Map of the Atlantic Forest (AF; blue shade) showing the orinal sampling points (red circles) and the quadrants encompassing the entire AF. The size of the circles represent the size o the original sampling area in the log scale. Green shade represent the quadrants where small mammal data was available. 

```{r Fig. 1 Study site, fig.width=8,fig.height=8,echo=FALSE,results='hide',message=FALSE,warning=FALSE}


par(xpd=NA)

#par (new=T)

plot(biomes[6,],col='lightblue',border="0",xlim=c(-45,-38))

#plot(subset(wclim.clipped,"bio1"),add=T)
plot(brazil,add=T,lwd=2)
#plot(biomes[6,],add=T,col=adjustcolor(4,alpha=.2),border=0)

rect(environment.AF.2d$AF.Long2-1,environment.AF.2d$AF.Lat2-1,environment.AF.2d$AF.Long2+1,environment.AF.2d$AF.Lat2+1,col=adjustcolor("darkgrey",alpha=.1),border=adjustcolor("darkgrey",alpha=1))

rect(environment.2d$Long2-1,environment.2d$Lat2-1,environment.2d$Long2+1,environment.2d$Lat2+1,col=adjustcolor("green",alpha=.2),border=adjustcolor("darkgrey",alpha=1))
points(mammal.data$Long,mammal.data$Lat,cex=log(ifelse(is.na(AREA..ha.),100,AREA..ha.)+1)/3,pch=21,bg=adjustcolor(2,alpha=.1),col=0)


range.size<-range(log(ifelse(is.na(AREA..ha.),100,AREA..ha.)+1))
divs=5
sizes<-seq(range.size[1]+(diff(range.size)/divs/2),range.size[2]-(diff(range.size)/divs/2),length=divs)

legend(-30,-5, legend=round(exp(sizes)) , pch = 21, col=0,pt.bg=adjustcolor(2,alpha=.5),pt.cex=sizes/3,y.intersp=exp(seq(log(1.2),log(1.5),length=divs)),x.intersp=3,bty="n")

text(-28,-4,"Area (ha)",cex=2)

#points(Long2,Lat2)
#rect(Long2-1,Lat2-1,Long2+1,Lat2+1,col=adjustcolor(3,alpha=.01))


#text(tapply(Long2+1,paste(Lat2,Long2),min),tapply(Lat2+1,paste(Lat2,Long2),min),
#tapply(Lat2,paste(Lat2,Long2),length),font=2)

#text(tapply(Long2+1,paste(Lat2,Long2),min),tapply(Lat2+1,paste(Lat2,Long2),min),
#tapply(AUTOR.E.ANO,paste(Lat2,Long2),function(x)nlevels(factor(as.character(x)))))

#text(environment.2d$Long2,environment.2d$Lat2,rowSums(species.2d))

```

  For estimating the influence of dispersal limitation on species local diversity (S) and turnover (Jaccard index; PCoA1 and PCoA2), we simulated the AF as a network of interconnected quadrants where the species or individuals could move between adjacent quadrants (Fig. 2). We used two models to recreate the species distribution under dispersal alone: the Mid-Domain spreading-dye model (Colwell and Hurtt 1994; Colwell and Lees 2000), and the analytical neutral approach borrowed from the population genetics (Nagylaki, 1980) and presented by Economo & Keitt (2008) for community ecology. These models were created just using the grouped data in quadrants because of the completeness of data, and due to computational limitation.
	In the Mid-Domain spreading dye model, we recorded the number of quadrants occupied by each small mammal species. For each species, one of the 26 quadrants was randomly selected and the species occurrence was spread from the selected quadrant to neighboring quadrants until the original number of quadrants was occupied. This procedure was repeated 10,000 times for the `ncol(species.2d)` species. Each quadrant had up to eight neighbors (Moore neighborhood), and the model was bounded by the domain where actual small mammal data was recorded (26 quadrants).


```{r Connectivity 26 and 56, echo=FALSE,message=FALSE,results='hide',warning=FALSE}

#Create a matrix of euclidean distances between all pairs of quadrants
dist.AF.2d<-as.matrix(dist(environment.AF.2d[,1:2]))

#Set as 1 the migration rate when the distance is below 4 and above 2 degrees (all adjacent quadrants, including diagonal but not self loops)

connect.AF.2d<-ifelse(dist.AF.2d<4&dist.AF.2d>0,1,0)
connect.2d<-connect.AF.2d[environment.2d$matchin.AF.2d,environment.2d$matchin.AF.2d]

#rownames(connect.2d)<-1:26

```

```{r Mid-Domain, cache=FALSE,results='hide',echo=FALSE,message=FALSE,warning=FALSE}

reps=999

MidD.sim<-array(NA,dim=c(nrow(connect.2d),ncol(species.2d),reps))

for(i in 1:reps){
  MidD.sim[,,i]<-MidD(connect.2d,colSums(species.2d),simplify=T)
  }

#### Extracting summary statistics

rich.MidD.vec<-apply(MidD.sim,3,rowSums)

similarity.MidD.vec<-apply(MidD.sim,3,function(mat)as.vector(as.matrix(vegdist(mat,"jaccard"))))


similarity.MidD.mean<-matrix(rowMeans(similarity.MidD.vec),nrow(species.2d),nrow(species.2d))

environment.2d$rich.MidD.mean<-rowMeans(rich.MidD.vec)
environment.2d$rich.MidD.sd<-apply(rich.MidD.vec,1,sd)

similarity.MidD.mean<-matrix(rowMeans(similarity.MidD.vec),nrow(species.2d),nrow(species.2d))
similarity.MidD.sd<-matrix(apply(similarity.MidD.vec,1,sd),nrow(species.2d),nrow(species.2d))

environment.2d[,paste("pcoa.MidD.jac.",1:3,sep="")]<-(
  prcomp(similarity.MidD.mean)$x)[,1:3]

#plot(pcoa.jac.1~pcoa.MidD.jac.1,data=environment.2d)

```

  In the neutral model, the whole area comprising the AF was divided in 56 2x2 degrees quadrants from which 26 had small mammal data available (Fig. 1). The model started with a single species occupying all the 56 quadrants. In each generation, new species were added in each quadrant by point speciation with rate v, set the same for all quadrants (see Economo & Keitt (2010) and Muneepeerakul et al. (2008) for more details and other uses). v represents the probability of an individual to become a new species but could also represent the addition of new species by immigration from a larger species pool outside the AF (eg. the Cerrado or Amazonian forests). To recreate the dispersal of individuals, we determined that a quadrant could just be colonized by a neighbor (Moore neighborhood), and that all quadrants had the same migration rate (parameter m). The local community size (number of individuals) was set the same for all quadrants (N = 100). The model was run for multiple generations, until the diversity within (PIE and HillPIE) and among quadrants (Morisita-Horn similarity) reached a steady-state (usually more than 30,000 generations).

#### Fig. 2. Map representing the connectivity of quadrants used to simulate the individual dispersal in the Mid Domain (A) and neutral (B) models.


```{r Fig. 2 - Connectivity map 26 and 56, echo=FALSE, fig.width=16,fig.height=8,results='hide',warning=FALSE}

par(mfrow=c(1,2))

plot(brazil,border="darkgrey")
rect(environment.2d$Long2-1,environment.2d$Lat2-1,environment.2d$Long2+1,environment.2d$Lat2+1,border=adjustcolor("darkgrey",alpha=1))

points(environment.2d$Long2,environment.2d$Lat2,pch=21,col=0,bg=2)

nnodes.2d<-nrow(environment.2d)

segments(matrix(environment.2d$Long2,nnodes.2d,nnodes.2d),
         matrix(environment.2d$Lat2,nnodes.2d,nnodes.2d),
         t(matrix(environment.2d$Long2,nnodes.2d,nnodes.2d)),
         t(matrix(environment.2d$Lat2,nnodes.2d,nnodes.2d)),col=connect.2d*2)

title("A)",cex.main=3,adj=0)

plot(brazil,border="darkgrey")
rect(environment.AF.2d$AF.Long2-1,environment.AF.2d$AF.Lat2-1,environment.AF.2d$AF.Long2+1,environment.AF.2d$AF.Lat2+1,border=adjustcolor("darkgrey",alpha=1))

points(environment.AF.2d$AF.Long2,environment.AF.2d$AF.Lat2,pch=21,col=0,bg=2)

nnodes.AF.2d<-nrow(environment.AF.2d)

segments(matrix(environment.AF.2d$AF.Long2,nnodes.AF.2d,nnodes.AF.2d),
         matrix(environment.AF.2d$AF.Lat2,nnodes.AF.2d,nnodes.AF.2d),
         t(matrix(environment.AF.2d$AF.Long2,nnodes.AF.2d,nnodes.AF.2d)),
         t(matrix(environment.AF.2d$AF.Lat2,nnodes.AF.2d,nnodes.AF.2d)),col=connect.AF.2d*2)

title("B)",cex.main=3,adj=0)

par(op)
```


  Differently from the Mid-domain model, the values of m, v, and N were initially set independently of the observed data. Because different combinations of these parameters can create the same patterns of species distribution (Etienne 2006?; Economo and Keitt 2010), and because estimates for these parameters based on empirical data are not available, we did not attempt to estimate realistic parameters, but focused on the general patterns that the model can produce (see discussion for implications of this procedure). N was arbitrarily defined as 100 individuals for all quadrants, and m and v were used as knobs to best fit the model to the observed similarity in species composition. These parameters were simultaneously tunned using the L-BFSG-S optimization algorithm. In summary, m and v were adjusted to minimize the differences between the predictions of the neutral model to the observed data, giving the best possible explanation of dispersal to the observed data (this procedure is conceptually analog to a regression analysis using maximum likelihood optimization). Because the number of individuals per quadrant was kept constant during the optimization, the differences in diversity were due to the location of a quadrant in the network and the number of neighbor quadrants, but not affected by the differences in abundance.

```{r set the number of generations to run, echo=FALSE,results='hide',warning=FALSE,message=FALSE}

nruns=1000

```


```{r Neutral Model - Optimization, cache=TRUE, results='hide',fig.show='hide',echo=FALSE,message=FALSE,warning=FALSE}

#Set initial parameters

m=0.03445190  #migration rate
v=0.00204737  #speciation rate
N=100 #Number of individuals in each node


optimized<-optim(c(m,v),lower=0.001,upper=0.5,method="L-BFGS-B",function(x){
  
M<-connect.AF.2d*(x[1]/rowSums(connect.AF.2d))
M[is.na(M)]<-0

diag(M)<-1-(rowSums(M)-diag(M))

#rowSums(M)

neutral.AF<-anetwork(N,M,x[2],nruns=1000)
F1=neutral.AF$finalF

morisita.AF.2d<-extractMH(neutral.AF$finalF)

resu<-sum((similarity.jac-(1-as.dist(morisita.AF.2d[environment.2d$matchin.AF.2d,environment.2d$matchin.AF.2d])))^2)

  print(resu)
  resu
  
#sum((decostand(prcomp(morisita.AF.2d[environment.2d$matchin.AF.2d,environment.2d$matchin.AF.2d])$x[,1],'range')-
#decostand(environment.2d$pcoa.jac.1,'range'))^2)

  })

```

```{r Neutral Model add run - use optimization parameters, message=FALSE,results='hide',echo=FALSE}

m<-optimized$par[1]
v<-optimized$par[2]

M<-connect.AF.2d*(m/rowSums(connect.AF.2d))
M[is.na(M)]<-0

diag(M)<-1-(rowSums(M)-diag(M))



neutral.AF<-anetwork(N,M,v,nruns=nruns)
F1=neutral.AF$finalF

environment.AF.2d$Hill<-1/(diag(neutral.AF$finalF))
morisita.AF.2d<-extractMH(neutral.AF$finalF)

environment.AF.2d[,paste("pcoa.mor.AF",1:3,sep="")]<-prcomp((morisita.AF.2d))$x[,1:3]
environment.AF.2d[,paste("pcoa.mor.",1:3,sep="")]<-environment.AF.2d[,paste("pcoa.mor.AF",1:3,sep="")]*NA

environment.AF.2d[environment.2d$matchin.AF.2d,paste("pcoa.mor.",1:3,sep="")]<-#PCA.AF[,1:3]
  prcomp(morisita.AF.2d[environment.2d$matchin.AF.2d,environment.2d$matchin.AF.2d])$x[,1:3]

#plot(environment.2d$Lat2,decostand(environment.2d$pcoa.jac.1,'range'),bg="gold",pch=22)
#points((environment.AF.2d$AF.Lat2),decostand(environment.AF.2d$pcoa.mor.1,'range',na.rm=T),bg=1,pch=21)
#points(environment.2d$Lat2,decostand(environment.2d$pcoa.MidD.jac.1,'range'),bg=2,pch=23)

#plot(decostand(prcomp(morisita.AF.2d[environment.2d$matchin.AF.2d,environment.2d$matchin.AF.2d])$x[,1],'range'),decostand(environment.2d$pcoa.jac.1,'range'))

```

  The model proposed by Economo and Keitt (2008) is probabilistic and does not require the simulation of each individual in the metacommunity, being less computationally intensive. This model allowed us to investigate thoroughly the parameter space of m and v to find the best explanatory model for the observed data. However, because the model is based on probabilities, it does not allow one to calculate statistics based on the raw data (eg. the Jaccard similarity index). Because not all original studies recorded species abundances, we compared the Morisita-Horn from the neutral model and the Jaccard indexis from the data for optimization. These indexes are usulally highly correlated and we believe this procedure did not have profound effects on the analysis (CITATION - CHAO?). 
  To calculate the Jaccard similarity index from the neutral model, We  simulated each individual in the metacommunity using the previously optimized parameters. We run an initial buffer of 30,000 generations. Then the model was run for additional 1000 generations 5,000 times, representing 5,000 simulations. The mean of all the 5,000 simulations was used to calculate the remain summary statistics (see below). The correlation between the probabilistic and the simulated model was 99.98% when comparing the Morisita-Horn index of pairwise similarity, so we believe the simulations run long enough to capture the final predictions of the neutral model.

```{r neutral_theory_real_simulation, results='hide',message=FALSE,echo=FALSE}

# Might take more than 12 hours to run in a regular computer

N<-matrix(N,nrow(M))

if(file.exists("neutral.sim.ind10k.txt")){
  
  neutral.sim.ind<- read.table("neutral.sim.ind10k.txt",header=TRUE)
  
  }else{
    
    #m=0.01790858  #migration rate
    #v=0.0017789240  #speciation rate
    #N=100 #Number of individuals in each node
    
    reps2<-10000
    initbuffer<-1
    
    sp.abund2<-simunetwork(N,M,v,nruns=initbuffer,simplify=FALSE)
    
    neutral.sim.ind<-matrix(NA,sum(N),reps2)
    
    for(rep in 1:reps2){
      
      sp.abund2<-simunetwork(N,M,v,nruns=nruns-1,simplify=FALSE,sp.abund=sp.abund2)
      
      neutral.sim.ind[,rep]<-sp.abund2
      
      #print(rep)
      }
    
    write.table(neutral.sim.ind,file="neutral.sim.ind10k.txt")
    
    #tapply(rep(1,sum(N)),list(rep(1:length(N),N),neutral.sim.ind[,1]),sum)
    
    }



```

```{r Calculating_statistics_from_neutral_real_simu, message=FALSE, results='hide',echo=FALSE}


similarity.neutral.total<-array(NA,dim=c(nrow(environment.AF.2d),nrow(environment.AF.2d),ncol(neutral.sim.ind)))
similarity.neutral.jac.total<-array(NA,dim=c(nrow(environment.AF.2d),nrow(environment.AF.2d),ncol(neutral.sim.ind)))
similarity.neutral<-array(NA,dim=c(nrow(environment.2d),nrow(environment.2d),ncol(neutral.sim.ind)))
similarity.neutral.jac<-array(NA,dim=c(nrow(environment.2d),nrow(environment.2d),ncol(neutral.sim.ind)))
hill.neutral<-matrix(NA,nrow(environment.AF.2d),ncol(neutral.sim.ind))
rich.neutral<-matrix(NA,nrow(environment.AF.2d),ncol(neutral.sim.ind))

for(i in 1:ncol(neutral.sim.ind)){
  
  ver<-tapply(rep(1,sum(N)),list(rep(1:length(N),N),neutral.sim.ind[,i]),sum)
  ver[is.na(ver)]<-0
  
  similarity.neutral.total[,,i]<-as.matrix(vegdist(ver,"morisita"))
  similarity.neutral.jac.total[,,i]<-as.matrix(vegdist(ver,"jaccard"))
  
  similarity.neutral[,,i]<-as.matrix(vegdist(ver,"morisita"))[environment.2d$matchin.AF.2d,environment.2d$matchin.AF.2d]
  similarity.neutral.jac[,,i]<-as.matrix(vegdist(ver,"jaccard"))[environment.2d$matchin.AF.2d,environment.2d$matchin.AF.2d]
  
  hill.neutral[,i]<-(1/(rowSums((ver/rowSums(ver))^2)*(rowSums(ver)-1)/(rowSums(ver))))
  rich.neutral[,i]<-rowSums(ver>0)
  }

environment.AF.2d$rich.neutral.mean<-rowMeans(rich.neutral)
environment.AF.2d$rich.neutral.sd<-apply(rich.neutral,1,sd)

environment.AF.2d$hill.neutral.mean<-rowMeans(hill.neutral)
environment.AF.2d$hill.neutral.sd<-apply(hill.neutral,1,sd)

environment.AF.2d[,paste("pcoa.mor.neutral.total.",1:3,sep="")]<-environment.AF.2d[,paste("pcoa.mor.AF",1:3,sep="")]*NA

environment.AF.2d[,paste("pcoa.jac.neutral.total.",1:3,sep="")]<-environment.AF.2d[,paste("pcoa.mor.AF",1:3,sep="")]*NA

environment.AF.2d[,paste("pcoa.mor.neutral.",1:3,sep="")]<-environment.AF.2d[,paste("pcoa.mor.AF",1:3,sep="")]*NA

environment.AF.2d[,paste("pcoa.jac.neutral.",1:3,sep="")]<-environment.AF.2d[,paste("pcoa.mor.AF",1:3,sep="")]*NA


environment.AF.2d[,paste("pcoa.mor.neutral.total.",1:3,sep="")]<-#PCA.AF[,1:3]
  prcomp(apply(similarity.neutral.total[,,round(.6*ncol(neutral.sim.ind)):ncol(neutral.sim.ind)],2,function(x)rowMeans(x)))$x[,1:3]

environment.AF.2d[,paste("pcoa.jac.neutral.total.",1:3,sep="")]<-#PCA.AF[,1:3]
  -prcomp(apply(similarity.neutral.jac.total[,,round(.6*ncol(neutral.sim.ind)):ncol(neutral.sim.ind)],2,function(x)rowMeans(x)))$x[,1:3]

similarity.neutral.mean<-apply(similarity.neutral[,,round(.6*ncol(neutral.sim.ind)):ncol(neutral.sim.ind)],2,function(x)rowMeans(x))

environment.AF.2d[environment.2d$matchin.AF.2d,paste("pcoa.mor.neutral.",1:3,sep="")]<-#PCA.AF[,1:3]
  prcomp(similarity.neutral.mean)$x[,1:3]

similarity.neutral.jac.mean<-apply(similarity.neutral.jac[,,round(.6*ncol(neutral.sim.ind)):ncol(neutral.sim.ind)],2,function(x)rowMeans(x))

environment.AF.2d[environment.2d$matchin.AF.2d,paste("pcoa.jac.neutral.",1:3,sep="")]<-#PCA.AF[,1:3]
  -prcomp(similarity.neutral.jac.mean)$x[,1:3]

#cor(environment.AF.2d$pcoa.mor.1,environment.AF.2d$pcoa.mor.neutral.1,use="c")


```

To test the association of the species diversity with the environment, we fit individual logistic regressions for all species against the predictor variables, allowing each species to vary independently of one another.

```{r logistic_regression_of_each_species, warning=FALSE, echo=FALSE}

glm.results.2d<-list()
bysp.glm.results.2d<-list()

glm.coef.2d<-list()
bysp.glm.coef.2d<-matrix(NA,ncol(species.2d),2,dimnames=list(colnames(species.2d),c('a','b')))

glm.variables.2d<-c("Long2","Lat2","conservation","vegetation",paste("bio",1:19,sep=""),"PCA.wclim.1","PCA.wclim.2")

for(k in glm.variables.2d){
  for(i in colnames(species.2d)){
    
    bysp.glm.results.2d[[i]]<-glm(as.formula(paste('species.2d[,i]~',paste(k))),family=binomial,data=environment.2d)
    bysp.glm.coef.2d[i,]<-coefficients(bysp.glm.results.2d[[i]])
    
    }
  glm.coef.2d[[k]]<-list(bysp.glm.coef.2d,environment.2d[k])
  }


#Estimate the probability of occurrence for each species in each site given the environmental variables

probs.2d<-lapply(glm.coef.2d,function(x){(exp(x[[1]][,1]+x[[1]][,2]%*%t(x[[2]])))/(1+exp(x[[1]][,1]+x[[1]][,2]%*%t(x[[2]])))}) 


```

We then summed the probability of occurrence generated by the logistic model for each species to estimate the expected number of species in each quadrant:
  
$$
\begin{equation}
\begin{split}
\hat S_i = \sum_{j=1}^{S}{\frac{e^{X_i\beta_j}}{1+e^{X_i\beta_j}}}
\end{split}
\end{equation}
$$
  
Where $X_i$ denotes a vector of the environmental variables in the quadrant $i$, and $\beta_j$ is a vector with the coefficients from the logistic regression of the species $j$.

```{r extract predictions of the logistic curve, echo=FALSE, results='hide',warning=FALSE}

Hill.logis<-data.frame(Hill.logis=lapply(probs.2d,function(x)1/(1-(colSums((x/colSums(x))^2)))))
rich.logis<-data.frame(rich.logis=lapply(probs.2d,function(x)colSums(x)))

environment.AF.2d[,as.character(colnames(Hill.logis))]<-NA
environment.AF.2d[,as.character(colnames(rich.logis))]<-NA

environment.AF.2d[environment.2d$matchin.AF.2d,colnames(Hill.logis)]<-Hill.logis
environment.AF.2d[environment.2d$matchin.AF.2d,colnames(rich.logis)]<-rich.logis

```

To calculate the raw statistics based on these probabilities, we simulated the distribution of each species based on the probabilities of occurrence generated by the logistic curve, similarly to what was done for the neutral model. For each species, we counted the number of quadrants where the species was observed. Thus we spread the species into the map based on its probability of occurrence until the number of quadrants occupied in the simulation matched the number observed. This allowed each species to vary independently, and to the relationship between the environmental variables and the response variables (eg. number of species) to be non-linear. Differently from the non-linearities that could be used in other statistical tests, such as Generalized additive models, the deterministic part of this model has an underlying mechanistic function (logistic).


```{r logistic simulation and extract predictions, echo=FALSE,results='hide',warning=FALSE}

#### Simulate the distribution of individuals using the probabilities and then extract the jaccard index

reps=999

similarity.logis.jac<-array(NA,dim=c(nrow(environment.2d),nrow(environment.2d),reps))

species.2d.logis.ls<-list()
similarity.logis.jac.ls<-list()
  
for(j in glm.variables.2d){
  
#  j=glm.variables.2d[[25]]
 
  species.2d.logis.reps<-list()
  
  for(k in 1:reps){

  species.2d.logis<-species.2d*0

    for(i in 1:ncol(species.2d.logis)){
      
      species.2d.logis[sample(nrow(species.2d.logis),sum(species.2d[,i]),prob=probs.2d[[j]][i,]),i]<-1
      
      }
    
    similarity.logis.jac[,,k]<-as.matrix(vegdist(species.2d.logis,"jaccard"))
    species.2d.logis.reps[[k]]<-species.2d.logis

    }
  
  similarity.logis.jac.ls[[j]]<-similarity.logis.jac
  species.2d.logis.ls[[j]]<-species.2d.logis.reps
    
  environment.AF.2d[,paste("pcoa.logis.jac.",j,".",1:3,sep="")]<-NA
  
  environment.AF.2d[environment.2d$matchin.AF.2d,paste("pcoa.logis.jac.",j,".",1:3,sep="")]<-
    prcomp(apply(similarity.logis.jac,2,rowMeans))$x[,1:3]
  
  }


```

```{r binding_all_data_frames, echo=FALSE,results='hide',warning=FALSE}

environment.AF.2d[,colnames(environment.2d)]<-NA
environment.AF.2d[environment.2d$match,colnames(environment.2d)]<-environment.2d
```

We compared the three simulation models (Mid Domain, Neutral, and based on logistic regressions) by their Mean Square Error (MSE; Gotelli et al. 2009). The MSE was calculated as the sum of the squared bias and model variance, so the MSE is a balance between precision and accuracy (see Gotelli et al. 2009 and Appendix S3 for detailed description).

```{r MSE richness,echo=FALSE,results='hide',warning=FALSE}

O<-environment.2d[!is.na(environment.2d[,"rich"]),"rich"]

S<-rich.MidD.vec
E<-rowMeans(S)

s.bias.sq.MidD<-sum((O-E)^2)
s.var.MidD<-(sum(colSums((S-E)^2)))/(ncol(S)-1)
s.mse.MidD = s.bias.sq.MidD + s.var.MidD

S<-rich.neutral[!is.na(environment.AF.2d[,"rich"]),]
E<-rowMeans(S)

s.bias.sq.neutral<-sum((O-E)^2)
s.var.neutral<-(sum(colSums((S-E)^2)))/(ncol(S)-1)
s.mse.neutral = s.bias.sq.neutral + s.var.neutral

s.bias.sq.logis<-{}
s.var.logis<-{}
s.mse.logis = {}

for (i in glm.variables.2d){ 

S<- do.call(cbind,lapply(species.2d.logis.ls[[i]],rowSums))

E<-rowMeans(S)

s.bias.sq.logis[i]<-sum((O-E)^2)
s.var.logis[i]<-(sum(colSums((S-E)^2)))/(ncol(S)-1)
s.mse.logis[i] = s.bias.sq.logis[i] + s.var.logis[i]

}

```

```{r MSE composition,echo=FALSE,results='hide',warning=FALSE}

O<-as.vector(as.matrix(similarity.jac))

S<-similarity.MidD.vec
E<-rowMeans(S)

s.bias.sq.MidD.jac<-sum((O-E)^2)
s.var.MidD.jac<-(sum(colSums((S-E)^2)))/(ncol(S)-1)
s.mse.MidD.jac = s.bias.sq.MidD.jac + s.var.MidD.jac

S<-apply(similarity.neutral.jac,3,as.vector)
E<-rowMeans(S)
E<-as.vector(1-morisita.AF.2d[environment.2d$matchin.AF.2d,environment.2d$matchin.AF.2d]) ### CHANGE

s.bias.sq.neu.jac<-sum((O-E)^2)
s.var.neu.jac<-(sum(colSums((S-E)^2)))/(ncol(S)-1)
s.mse.neu.jac <- s.bias.sq.neu.jac + s.var.neu.jac

s.bias.sq.logis.jac<-{}
s.var.logis.jac<-{}
s.mse.logis.jac<- {}

for (i in glm.variables.2d){ 
  
S<-apply(similarity.logis.jac.ls[[i]],3,as.vector)
E<-rowMeans(S)
  
s.bias.sq.logis.jac[i]<-sum((O-E)^2)
s.var.logis.jac[i]<-(sum(colSums((S-E)^2)))/(ncol(S)-1)
s.mse.logis.jac[i] = s.bias.sq.logis.jac[i] + s.var.logis.jac[i]

}

```

Additionally, we tested for the direct association of the response variables against the environmental predictors. For this test, we used a linear regression model (OLS) starting with all environmental predictors in the model. We then tested all sets of variables in each regression model, and the best fit model was chosen based on the Akaike Information Criterion (AIC) values. For the grouped data, we created three sets of models: (1) Using the neutral and Mid-domain predictions as a predictor variables along with the environmental variables in the model as suggested by Letten et al. (2013); (2) using the neutral and Mid-domain predictions as a null hypothesis and testing for association of residuals with the environmental variables; and (3) a regression with only the environmental variables as predictors. We used both the raw environmental data and the prediction from the logistic simulation as predictor variables. This gave a total of 10 models (Table XX). The models were compared by their AIC values.
  
Table XX. MidD+Env; ResMidD+Env; MidD+LEnv; ResMidD+LEnv; Neutral+Env; ResNeutral+Env; Neutral+LEnv; ResNeutral+LEnv; Env; LEnv. 
		
```{r regressions, echo=FALSE, results='hide',warning=FALSE}

MR1.1<-lm(rich~std.dist.coast+std.conservation+std.vegetation+std.PCA.wclim.1+std.PCA.wclim.2,data=decostand(environment.AF.2d,"standardize"))

MR1.2<-update(MR1.1,~.+rich.neutral.mean)
MR1.3<-update(MR1.1,~.+rich.MidD.mean)

MR1.4<-update(MR1.1,~1+rich.neutral.mean)
MR1.5<-update(MR1.1,~1+rich.MidD.mean)

MR1.6<-lm(MR1.4$residuals~std.dist.coast+std.conservation+std.vegetation+std.PCA.wclim.1+std.PCA.wclim.2,data=decostand(environment.2d,"standardize"))

MR1.7<-lm(MR1.5$residuals~std.dist.coast+std.conservation+std.vegetation+std.PCA.wclim.1+std.PCA.wclim.2,data=decostand(environment.2d,"standardize"))

MR1.8<-lm(rich~rich.logis.conservation+rich.logis.vegetation+rich.logis.PCA.wclim.1+rich.logis.PCA.wclim.2,data=decostand(environment.AF.2d,"standardize"))

MR1.9<-update(MR1.8,~1+rich.neutral.mean)
MR1.10<-update(MR1.8,~1+rich.MidD.mean)

##### Composition

MC1.1<-lm(pcoa.jac.1~std.dist.coast+std.conservation+std.vegetation+std.PCA.wclim.1+std.PCA.wclim.2,data=decostand(environment.AF.2d,"standardize"))

MC1.2<-update(MC1.1,~.+pcoa.jac.neutral.1) # Change direction
MC1.3<-update(MC1.1,~.+pcoa.MidD.jac.1)

MC1.4<-update(MC1.1,~1+pcoa.jac.neutral.1) # Change direction
MC1.5<-update(MC1.1,~1+pcoa.MidD.jac.1)

MC1.6<-lm(MC1.4$residuals~std.dist.coast+std.conservation+std.vegetation+std.PCA.wclim.1+std.PCA.wclim.2,data=decostand(environment.2d,"standardize"))

MC1.7<-lm(MC1.5$residuals~std.dist.coast+std.conservation+std.vegetation+std.PCA.wclim.1+std.PCA.wclim.2,data=decostand(environment.2d,"standardize"))

MC1.8<-lm(pcoa.jac.1~pcoa.logis.jac.conservation.1+pcoa.logis.jac.vegetation.1+pcoa.logis.jac.PCA.wclim.1.1+pcoa.logis.jac.PCA.wclim.2.1,data=decostand(environment.AF.2d,"standardize"))

MC1.9<-update(MC1.8,~1+pcoa.jac.neutral.1)
MC1.10<-update(MC1.8,~1+pcoa.MidD.jac.1)


#####

MC2.1<-lm(pcoa.jac.2~std.dist.coast+std.conservation+std.vegetation+std.PCA.wclim.1+std.PCA.wclim.2,data=decostand(environment.AF.2d,"standardize"))

MC2.2<-update(MC2.1,~.+pcoa.jac.neutral.2) # Change direction
MC2.3<-update(MC2.1,~.+pcoa.MidD.jac.2)

MC2.4<-update(MC2.1,~1+pcoa.jac.neutral.2) # Change direction
MC2.5<-update(MC2.1,~1+pcoa.MidD.jac.2)

MC2.6<-lm(MC2.4$residuals~std.dist.coast+std.conservation+std.vegetation+std.PCA.wclim.1+std.PCA.wclim.2,data=decostand(environment.2d,"standardize"))

MC2.7<-lm(MC2.5$residuals~std.dist.coast+std.conservation+std.vegetation+std.PCA.wclim.1+std.PCA.wclim.2,data=decostand(environment.2d,"standardize"))

MC2.8<-lm(pcoa.jac.2~pcoa.logis.jac.conservation.2+pcoa.logis.jac.vegetation.2+pcoa.logis.jac.PCA.wclim.1.2+pcoa.logis.jac.PCA.wclim.2.2,data=decostand(environment.AF.2d,"standardize"))

MC2.9<-update(MC2.8,~1+pcoa.jac.neutral.2)
MC2.10<-update(MC2.8,~1+pcoa.MidD.jac.2)

```

  Finally, we tested for patterns of distance-decay in the species similarity using Mantel and Partial Mantel tests correlating the matrix of Jaccard similarity (M) to the geographical distance (D) and environmental dissimilarity (E) matrices (Euclidean distance) (see Thompson and Townsend 2006). Legendre et al. (2005) and Tuomisto and Ruokolainen (2006; 2008) suggest using multiple regression on similarity matrices to separate the effects of niche and neutral processes. However, there is a strong debate about the validity of these models (Legendre et al. 2008; Tuomisto and Ruokolainen 2008). Some authors also suggest using partial Redundancy Analysis (Borcard et al. 1992) for this purpose (Gilbert and Lechowicz 2004), but this method also has serious limitations (Smith and Lundholm 2010). We preferred to base our discussion on the mantel tests and multiple regressions using the summarized data (each quadrant as a unit), as described above. 


```{r mantel tests - local, message=FALSE,echo=FALSE,results='hide',warning=FALSE}

man.geo.loc<-mantel(similarity.jac.loc,geodist.loc)
man.env.loc<-mantel(similarity.jac.loc,envdist.loc)

pman.geo.loc<-mantel.partial(similarity.jac.loc,geodist.loc,envdist.loc)
pman.env.loc<-mantel.partial(similarity.jac.loc,envdist.loc,geodist.loc)

#summary(rda.loc<-rda(species.loc,environment[grep("std",colnames(environment))][3:24],environment[,c("Lat","Long")]))

#anova(rda.loc)

```


```{r mantel tests - 2d, message=FALSE,results='hide',echo=FALSE,warning=FALSE}

man.geo.2d<-mantel(similarity.jac,geodist.2d)
man.env.2d<-mantel(similarity.jac,envdist.2d)

pman.geo.2d<-mantel.partial(similarity.jac,geodist.2d,envdist.2d)
pman.env.2d<-mantel.partial(similarity.jac,envdist.2d,geodist.2d)

```

  All the analyses were conducted in the R program (R Development Core Team, 2013). The models and most of the summary statistics calculations were implemented by the authors, and are available as a supplementary material (see Appendix S3). We used the packages vegan (Oksanen et al., 2008) for the remaining analyses.

		
### Results

  All the models had a very poor fit to species richness. The model with the lowest mean square error and bias was the logistic using only conservation status as a predictor followed by the logistic model based on vegetation type (Table 1). The model with the lowest variance was the neutral model, but the difference among the models was much smaller than for the bias (Table 1).

#### Table 1. Bias, Variance and Mean Square Error of the Mid Domain, Neutral and Logistic simulation models for species richness. The Mean Square Error is the sum of the Bias and Variance.

  The regression models gave very similar results. The model with the lowest AIC was the linear regression of the species richness against the raw environmental predictors (Distance to the coast, vegetation, conservation and PCA axes of edaphic conditions) (Table 2). However, the nutral and Mid-Domain models were within 2
  
summary(MR1.1)
  

```{r AICs richness, echo=FALSE}

AIC(MR1.1,MR1.2,MR1.3,MR1.4,MR1.5,MR1.6,MR1.7,MR1.8,MR1.9,MR1.10)

```



```{r AICs composition, echo=FALSE}

AIC(MC1.1,MC1.2,MC1.3,MC1.4,MC1.5,MC1.6,MC1.7,MC1.8,MC1.9,MC1.10)
AIC(MC2.1,MC2.2,MC2.3,MC2.4,MC2.5,MC2.6,MC2.7,MC2.8,MC2.9,MC2.10)

```
  


``` {r MSE - rich Results,echo=FALSE,results='asis'}

print(xtable(data.frame(BIASsq=c(MidD=s.bias.sq.MidD,Neutral=s.bias.sq.neutral,s.bias.sq.logis),
VAR=c(MidD=s.var.MidD,Neutral=s.var.neutral,s.var.logis),
sMSE=c(MidD=s.mse.MidD,Neutral=s.mse.neutral,s.mse.logis))
),type="html",html.table.attributes="border=0, bgcolor=#989898")

```


#### Table 2. Bias, Variance and Mean Square Error of the Mid Domain, Neutral and Logistic simulation models for the jaccard pairwise similarity. The Mean Square Error is the sum of the Bias and Variance.

```{r MSE - comp Results,echo=FALSE,results='asis'}

print(xtable(data.frame(BIASsq=c(MidD=s.bias.sq.MidD.jac,Neutral=s.bias.sq.neu.jac,s.bias.sq.logis.jac),
VAR=c(MidD=s.var.MidD.jac,Neutral=s.var.neu.jac,s.var.logis.jac),
sMSE=c(MidD=s.mse.MidD.jac,Neutral=s.mse.neu.jac,s.mse.logis.jac))
),type="html",html.table.attributes="border=0, bgcolor=#989898")

```


#### Fig XX

```{r Map Richness Mid Domain vs Neutral,fig.width=18,fig.height=9,echo=FALSE,message=FALSE,results='hide',warning=FALSE}

par(mfrow=c(1,2))

plot(brazil)
rect(environment.2d$Long2-1,environment.2d$Lat2-1,environment.2d$Long2+1,environment.2d$Lat2+1,
     col=adjustcolor(color.select(environment.2d$rich.MidD.mean),alpha=.8))
title("A)",cex=3,adj=0)

plot(brazil)
rect(environment.AF.2d$AF.Long2-1,environment.AF.2d$AF.Lat2-1,environment.AF.2d$AF.Long2+1,environment.AF.2d$AF.Lat2+1,
     col=adjustcolor(color.select(environment.AF.2d$rich.neutral.mean),alpha=.8))
title("B)",cex=3,adj=0)

par(op)
```

## Fig XX

```{r Map Composition Mid Domain vs Neutral,fig.width=18,fig.height=9,echo=FALSE,message=FALSE,results='hide'}

par(mfrow=c(1,2))

plot(brazil)
rect(environment.2d$Long2-1,environment.2d$Lat2-1,environment.2d$Long2+1,environment.2d$Lat2+1,
     col=adjustcolor(color.select(environment.2d$pcoa.MidD.jac.1),alpha=.8))
title("A)",cex=3,adj=0)

plot(brazil)
rect(environment.AF.2d$AF.Long2-1,environment.AF.2d$AF.Lat2-1,environment.AF.2d$AF.Long2+1,environment.AF.2d$AF.Lat2+1,
     col=adjustcolor(color.select(environment.AF.2d$pcoa.jac.neutral.total.1),alpha=.8))
title("B)",cex=3,adj=0)

par(op)
```

## Fig XX

```{r plot all predictions against lat, fig.width=16,fig.height=8,message=FALSE,results='hide',echo=FALSE}

par(mfrow=c(1,2))

plot(environment.2d$Lat2,decostand(environment.2d$pcoa.jac.1,'range'),bg="gold",pch=22)

points(environment.2d$Lat2,decostand(environment.2d$pcoa.MidD.jac.1,'range'),bg=2,pch=23)

points((environment.AF.2d$AF.Lat2),decostand(environment.AF.2d$pcoa.mor.1,'range',na.rm=T),bg=4,pch=24)

points((environment.AF.2d$AF.Lat2),decostand(environment.AF.2d$pcoa.mor.neutral.1,'range',na.rm=T),bg=1,pch=3,cex=2)

plot.new()

legend("topleft",c("Observed","MidD","Neutral-ana","Neutral-simu"),pch=c(22,23,24,3),pt.bg=c("gold",2,4,3),bty="n",y.intersp=1.2,cex=2)

#plot(decostand(environment.AF.2d$pcoa.mor.1,'range',na.rm=T),decostand(environment.AF.2d$pcoa.mor.neutral.1,'range',na.rm=T),bg=1,pch=3,cex=2)
#plot(environment.AF.2d$pcoa.mor.1,environment.AF.2d$pcoa.mor.neutral.1,bg=1,pch=3,cex=2)

```


## Fig XX

```{r plot logis hill,fig.align='center',fig.width=8,fig.height=8, echo=FALSE,warning=FALSE}

par(op)
par(mgp=c(.2,0,0))
par(mar=c(2,2,0,0))

par(mfrow=c(ceiling(length(Hill.logis)/ceiling(sqrt(length(Hill.logis)))),ceiling(sqrt(length(Hill.logis)))))

for (i in glm.variables.2d){plot(Hill.logis[[paste("Hill.logis.",i,sep="")]]~environment.2d[[i]],pch=21,bg=color.select(Hill.logis[[paste("Hill.logis.",i,sep="")]]),xlab=i,ylab="Diversity",axes=FALSE);box()}

```

```{r plot logis rich and srich,echo=FALSE,results='hide'}

par(mfrow=c(ceiling(length(rich.logis)/ceiling(sqrt(length(rich.logis)))),ceiling(sqrt(length(rich.logis)))))

for (i in glm.variables.2d) {

ver<- do.call(cbind,lapply(species.2d.logis.ls[[i]],rowSums))

plot(rowSums(species.2d)~environment.2d[[i]],xlab=i,ylab="Diversity",axes=FALSE,ylim=c(0,max(rowSums(species.2d))),pch=21,col=0,bg="dark grey")  
  
points(rowMeans(ver)~environment.2d[[i]],xlab=i,ylab="Diversity",axes=FALSE,ylim=c(0,max(rowSums(species.2d))),pch=21,col=0,bg=1)  
  
points(rich.logis[[paste("rich.logis.",i,sep="")]]~environment.2d[[i]],pch=21,bg=color.select(rich.logis[[paste("rich.logis.",i,sep="")]]))
  
  box()

  }

```

## Fig XX

```{r Hill numbers and Richness on the map - logistic, echo=FALSE,warning=FALSE,message=FALSE}
################################
# Plotting the diversity predictions on the map

attach(environment.2d)

par(mfrow=c(ceiling(length(Hill.logis)/ceiling(sqrt(length(Hill.logis)))),ceiling(sqrt(length(Hill.logis)))),mar=c(0,0,0,0))
for (i in glm.variables.2d){
  plot(brazil)
  title(main=i,line=-3)
  points(Long2,Lat2,pch=22,bg='darkgrey',col=0,cex=.5)
  rect(Long2-1,Lat2-1,Long2+1,Lat2+1,col=color.select(Hill.logis[[paste("Hill.logis.",i,sep="")]]))
  plot(brazil,add=T)
  }

```

## Fig XX2

```{r what, echo=FALSE}

par(mfrow=c(ceiling(length(rich.logis)/ceiling(sqrt(length(rich.logis)))),ceiling(sqrt(length(rich.logis)))),mar=c(0,0,0,0))
for (i in glm.variables.2d){
  plot(brazil)
  title(main=i,line=-3)
  points(Long2,Lat2,pch=22,bg='darkgrey',col=0,cex=.5)
  rect(Long2-1,Lat2-1,Long2+1,Lat2+1,col=color.select(rich.logis[[paste("rich.logis.",i,sep="")]]))
  plot(brazil,add=T)
  }

detach(environment.2d)

```

### Figures comparing the models

```{r comparisons of the models, echo=FALSE}

#Environment

vars<-c("Lat2","Long2","conservation","vegetation",paste("bio",1:19,sep=""),"PCA.wclim.1","PCA.wclim.2")

par(mgp=c(.2,0,0))
par(mar=c(2,2,0,0))
par(mfrow=c(ceiling(length(vars)/ceiling(sqrt(length(vars)))),ceiling(sqrt(length(vars)))))

for (i in vars){
  plot(as.formula(paste("rich~",i)),data=environment.AF.2d[!is.na(environment.AF.2d$bio19),],axes=FALSE)
  abline(lm(environment.AF.2d[!is.na(environment.AF.2d[,"rich"]),paste("rich",sep="")]~environment.AF.2d[!is.na(environment.AF.2d[,"rich"]),i]),lwd=2,col=2)
  abline(lm(environment.AF.2d[!is.na(environment.AF.2d[,"rich"]),paste("rich.logis.",i,sep="")]~environment.AF.2d[!is.na(environment.AF.2d[,"rich"]),i]),lwd=2,col=4)
  points(environment.AF.2d[,i],environment.AF.2d[,paste("rich.logis.",i,sep="")],pch=21,bg=2,col=0)
  box()
  #abline(lm(as.formula(paste("rich~",i)),data=environment.AF.2d))
  }

# Neutral

par(op)
plot(rich~rich.neutral.mean,data=environment.AF.2d[!is.na(environment.AF.2d[,"rich"]),],pch=21,col=NULL,bg=4)
abline(lm(rich~rich.neutral.mean,data=environment.AF.2d[!is.na(environment.AF.2d[,"rich"]),]))

# Mid Domain

par(op)
plot(rich~rich.MidD.mean,data=environment.AF.2d[!is.na(environment.AF.2d[,"rich"]),],col=NULL,bg=2,pch=21)
abline(lm(rich~rich.MidD.mean,data=environment.AF.2d[!is.na(environment.AF.2d[,"rich"]),]))

```

### Fig sp comp

```{r species composition plot, echo=FALSE}

vars<-c("Lat2","Long2","conservation","vegetation",paste("bio",1:19,sep=""),"PCA.wclim.1","PCA.wclim.2")

par(mgp=c(.2,0,0))
par(mar=c(2,2,0,0))
par(mfrow=c(ceiling(length(vars)/ceiling(sqrt(length(vars)))),ceiling(sqrt(length(vars)))))

for (i in vars){
  plot(as.formula(paste("pcoa.jac.1~",i)),data=decostand(environment.AF.2d[!is.na(environment.AF.2d$bio19),],"range"),axes=FALSE)
  abline(lm(as.formula(paste("pcoa.jac.1~",i)),data=decostand(environment.AF.2d[!is.na(environment.AF.2d$bio19),],"range")),lwd=2,col=4)
  abline(lm(as.formula(paste("pcoa.logis.jac.",i,".1~",i,sep="")),data=decostand(environment.AF.2d[!is.na(environment.AF.2d$bio19),],"range")),lwd=2,col=2)
  points(decostand(environment.AF.2d[!is.na(environment.AF.2d$bio19),i],"range"),decostand(environment.AF.2d[!is.na(environment.AF.2d$bio19),paste("pcoa.logis.jac.",i,".1",sep="")],"range"),pch=21,bg=2,col=0)
  box()
  #abline(lm(as.formula(paste("rich~",i)),data=environment.AF.2d))
  }

par(op)
plot(pcoa.jac.1~pcoa.jac.neutral.1,data=environment.AF.2d[!is.na(environment.AF.2d[,"rich"]),])

abline(lm(environment.AF.2d[!is.na(environment.AF.2d[,"rich"]),"pcoa.jac.1"]~environment.AF.2d[!is.na(environment.AF.2d[,"rich"]),"pcoa.jac.neutral.1"]),lwd=2,col=4)

par(op)

#################
# Mid-Domain

par(op)

plot(pcoa.jac.1~pcoa.MidD.jac.1,data=environment.AF.2d[!is.na(environment.AF.2d[,"rich"]),])

abline(lm(pcoa.jac.1~pcoa.MidD.jac.1,data=environment.AF.2d[!is.na(environment.AF.2d[,"rich"]),]),lwd=2,col=2)


```

# Comparison of the observed and predicted by the models

```{r observed vs predicted, echo=FALSE}

par(mfrow=c(1,3))

plot(0:1,0:1,type="n",xlab="Predicted",ylab="Observed")

abline(0,1,lwd=2,lty=2)

title("Richness")

abline(lm(rich~rich.neutral.mean,data=decostand(environment.AF.2d[!is.na(environment.AF.2d[,"rich"]),],"range")),lwd=2,col=4)

abline(lm(rich~rich.MidD.mean,data=decostand(environment.AF.2d[!is.na(environment.AF.2d[,"rich"]),],"range")),lwd=2,col=2)

vars<-c("conservation","PCA.wclim.1","PCA.wclim.2")

# Species composition (PCA)

plot(0:1,0:1,type="n",xlab="Predicted",ylab="Observed")
abline(0,1,lwd=2,lty=2)

title("Species composition (PCA)")

abline(lm(pcoa.jac.1~pcoa.jac.neutral.1,data=decostand(environment.AF.2d[!is.na(environment.AF.2d[,"rich"]),],"range")),col=4)


abline(lm(pcoa.jac.1~pcoa.MidD.jac.1,data=decostand(environment.AF.2d[!is.na(environment.AF.2d[,"rich"]),],"range")),col=2)


#Species composition (Jaccard index )

plot(0:1,0:1,type="n",xlab="Predicted",ylab="Observed")

abline(0,1,lwd=2,lty=2)

title("Species composition (Jaccard)")

points(1-decostand(as.vector(as.dist(morisita.AF.2d[environment.2d$matchin.AF.2d,environment.2d$matchin.AF.2d])),"range")
,decostand(as.vector(similarity.jac),"range"),col=4)

points(decostand(as.vector(as.dist(similarity.MidD.mean)),"range")
,decostand(as.vector(similarity.jac),"range"),col=2)


abline(lm(decostand(as.vector(similarity.jac),"range")~decostand(-as.vector(as.dist(morisita.AF.2d[environment.2d$matchin.AF.2d,environment.2d$matchin.AF.2d])),"range"))
,col=4)


abline(lm(pcoa.jac.1~pcoa.MidD.jac.1,data=decostand(environment.AF.2d[!is.na(environment.AF.2d[,"rich"]),],"range")),col=2)


```

Mantel test

```{r Mantel and Partial Mantel results, echo=FALSE,results='asis'}

print(xtable(rbind("Local Geo"=man.geo.loc[c("statistic","signif")],
"Local Env"=man.env.loc[c("statistic","signif")],
"2d Geo"=man.geo.2d[c("statistic","signif")],
"2d Env"=man.env.2d[c("statistic","signif")],
"Local Geo-Env"=pman.geo.loc[c("statistic","signif")],
"Local Env-Geo"=pman.env.loc[c("statistic","signif")],
"2d Geo-Env"=pman.geo.2d[c("statistic","signif")],
"2d Env-Geo"=pman.env.2d[c("statistic","signif")])
),type="html",html.table.attributes="border=0, bgcolor=#989898")

```

Distance-Decay

### Fig. 5

```{r distance decay real.midDomain and neutral mor, echo=FALSE,results='hide',warning=FALSE}

plot(geodist.2d,1-similarity.jac,ylim=c(0,1),pch=21,bg="dark grey",col=NULL,xlab="Geographical distance (arc Degrees)", ylab="Jaccard similarity",cex.lab=2)

points(geodist.2d,as.dist(morisita.AF.2d[environment.2d$matchin.AF.2d,environment.2d$matchin.AF.2d]),pch=21,bg=adjustcolor(4,alpha=.2),col=NULL)

points(geodist.2d,1-as.dist(similarity.MidD.mean),pch=21,bg=adjustcolor(2,alpha=.2),col=NULL)

lines(levels(factor(geodist.2d)),tapply(as.dist(morisita.AF.2d[environment.2d$matchin.AF.2d,environment.2d$matchin.AF.2d]),geodist.2d,mean),lwd=2,col=4)

lines(levels(factor(geodist.2d)),tapply(1-as.dist(similarity.MidD.mean),geodist.2d,mean),lwd=2,col=2)

```


```{r detach_data, echo=FALSE,results='hide',warning=FALSE,message=FALSE}

detach(mammal.data)

```


```{r extracting_R_chunks, echo=FALSE, message=FALSE,warning=FALSE,results='hide'}


purl("All_analysis.Rmd")

```


```{r knit2html, echo=FALSE, eval=FALSE,results='hide'}

library(knitr)

knit2html("All_analysis.Rmd")

```
