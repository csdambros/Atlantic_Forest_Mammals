---
output: html_document
---


Comparing dispersal, environmental and mid-domain effects on species distribution
============================

`r rm(list=ls())`

```{r Markdownopt, results='hide',warning=FALSE,message=FALSE,echo=FALSE}

table.type="html"


```


##### By Dambros, Cáceres, Magnus, and Gotelli


>html updated at `r as.character(Sys.time())`

### Methods

#### Study site
 
  The study was conducted in the whole area recognized as the Atlantic forest biome (Fig. 1). This biome encompasses an extent of 102,012 km², but today representing only 7.9% of its original forest cover. It has several vegetation types such as rainforests, mixed (Araucarian) moist forests, semideciduous forests, dry forests and upland grasslands. Rainforests tend to occur near the coast and semideciduous and dry forests far from coast; mixed forests are common in the south of AF (SOS Mata Atlântica 2007). AF shows moist tropical and subtropical climates, without well-defined dry season, and annual mean temperatures above 15ºC (Leite, 2002). 


```{r Loading packages and functions, results='hide',message=FALSE,echo=FALSE,warning=FALSE}

require(raster)
require(rgdal)
require(maptools)
require(vegan)
require(xtable)
require(knitr)

source("anetwork.R")
source("MidD.R")
source("simunetwork.R")

Custom.Palette<- colorRampPalette(colors=c('lightblue','yellow','red'),bias=1,space='rgb')

#color.select<-function(x){Custom.Palette(101)[1+round(((x-min(x,na.rm=T))/diff(range(x,na.rm=TRUE)))*100)]}

color.select<-function(x,ref=x,palette=topo.colors){x[x<min(ref,na.rm=TRUE)]<-min(ref,na.rm=TRUE);x[x>max(ref,na.rm=TRUE)]<-max(ref,na.rm=TRUE);palette(101)[1+round(((x-min(ref,na.rm=TRUE))/diff(range(ref,na.rm=TRUE)))*100)]}


# Function to calculate the Nagelkerke r2
Nagr2<-function(model){(1 - exp((sum(model$residuals^2) - sum((model$residuals+model$fitted.values)^2))/nrow(model$model)))/(1 - exp(-sum((model$residuals+model$fitted.values)^2)/nrow(model$model)))}


op<-par(no.readonly=TRUE)
```

```{r Importing maps, results="hide",message=FALSE,echo=FALSE,warning=FALSE}

#The maps must be in a folder called "Shapefiles/" before running the code

folder<-"Shapefiles/"

brazil<-readShapeSpatial(paste(folder,"BR_Contorno.shp",sep=""))
biomes<-readShapeSpatial(paste(folder,"bioma.shp",sep=""))

```

#### Data collection

  We compiled a database based on the literature in which diverse authors have sampled small mammals along the AF (Appendix S1 in Supporting Information). We have used Google @ search tool for sampling articles, and the main keywords used in combination were “small mammal”, “marsupial”, “rodent”, “community”, “composition”, “richness”, “diversity”, and “Atlantic Forest”. Unpublished data sampled by NCC was also included (Appendix S1). There was some variation in the area covered by each surveyed study (see Appendix S1), but we have established a minimum of sampling effort for a given article to be accepted in our database: at least 1000 trap-nights, 6 months of field work, and use of wire type and/or Sherman live-traps installed on the ground or understory level of the forest. Besides that, and for independence assumptions, we have chosen surveyed areas distant at least 10 km from each other; most of the field surveys available in the literature sampled only one geographical location under this condition. From each selected survey, we obtained local species composition and abundance data when available. 
  We compiled the 19 environmental variables available in Bioclim (www.worldclim.org/bioclim) in a scale of 2.5 arc minutes: annual mean temperature (1), mean diurnal range (2), isothermality (3), temperature seasonality (4), maximum and minimum temperature of the warmest and coldest months (5 and 6), temperature annual range (7), mean temperature of the wettest, driest, warmest and coldest quarters (8-11), annual precipitation (12), precipitation of the wettest and driest months (13 and 14), precipitation seasonality (15), and precipitation of the wettest, direst, warmest and coldest quarters (16-19). Because most of the variables are correlated to each other, the climatic variables were summarized in a Principal Component axis. This axis was used a predictor variable in all models. We present the results using individual variables as supplements (see below).  
  Data on habitat quality were taken directly from information available on the articles consulted, and classified as categories of forest conservation (degrees 1 to 5), where a score of 5 means primary pristine forest, and disturbed secondary forest, including with clearings, has a score of 1.


```{r Importing data,message=FALSE,echo=FALSE,warning=FALSE}

mammal.data=read.csv('NC5.csv')# Data from each locality

```

```{r Importing environmental layers from worldclim, results="hide",message=FALSE,echo=FALSE,warning=FALSE}

wclim <- raster::getData("worldclim", var="bio", res=2.5, path="")
wclim.clipped<-crop(wclim,extent(-70,-30,-35,5))
#rm(wclim)


```

#### Analysis

  The standardized variables of habitat quality and the summarized climatic variables (PCA.clim1) were used as predictors of the species diversity and included in simulation models (see below). Latitude and Longitude were highly correlated with the climatic variables, so they were not included in the models as predictor variables, but were used to calculate the pairwise distance among sampling units.


```{r Transforming data and extract variables, results="hide",message=FALSE,echo=FALSE,warning=FALSE}

### Calculate the distance from the coast

poly<-(brazil@polygons)[[1]]@Polygons

LAT.coast<-unlist(lapply(poly,function(x){x@coords[,2]}))
LONG.coast<-unlist(lapply(poly,function(x){x@coords[,1]}))
long.chui<--(53+22/60+25/3600)

LONG.coast.east<-LONG.coast[LONG.coast>long.chui]
LAT.coast.east<-LAT.coast[LONG.coast>long.chui]

LONG.matrix.east<-t(matrix(LONG.coast.east,nrow=length(LONG.coast.east),ncol=length(mammal.data$Lat)))
LAT.matrix.east<-t(matrix(LAT.coast.east,nrow=length(LAT.coast.east),ncol=length(mammal.data$Lat)))

Longitude.matrix<-matrix(mammal.data$Long,nrow=length(mammal.data$Lat),ncol=length(LONG.coast.east))
Latitude.matrix<-matrix(mammal.data$Lat,nrow=length(mammal.data$Lat),ncol=length(LONG.coast.east))

LONG.diff<-LONG.matrix.east-Longitude.matrix
LAT.diff<-LAT.matrix.east-Latitude.matrix

Distance.coast.matrix<-sqrt(LONG.diff^2+LAT.diff^2)
mammal.data$Distance.coast<-apply(Distance.coast.matrix,1,min)

mammal.data$Long.closest<-apply(Distance.coast.matrix,1,function(x){LONG.coast.east[x==min(x)]})
mammal.data$Lat.closest<-apply(Distance.coast.matrix,1,function(x){LAT.coast.east[x==min(x)]})

#Grouping the latitude and longitude in 2x2 degrees (create new variables in the dataframe)
mammal.data$Long2<-floor(mammal.data$Long/2)*2+1
mammal.data$Lat2<-floor(mammal.data$Lat/2)*2+1

Longitude.matrix2<-matrix(mammal.data$Long2,nrow=length(mammal.data$Lat2),ncol=length(LONG.coast.east))
Latitude.matrix2<-matrix(mammal.data$Lat2,nrow=length(mammal.data$Lat2),ncol=length(LONG.coast.east))

LONG.diff2<-LONG.matrix.east-Longitude.matrix2
LAT.diff2<-LAT.matrix.east-Latitude.matrix2

Distance.coast.matrix2<-sqrt(LONG.diff2^2+LAT.diff2^2)
mammal.data$Distance.coast2<-apply(Distance.coast.matrix2,1,min)

mammal.data$Long.closest2<-apply(Distance.coast.matrix2,1,function(x){LONG.coast.east[x==min(x)]})
mammal.data$Lat.closest2<-apply(Distance.coast.matrix2,1,function(x){LAT.coast.east[x==min(x)]})

rm(Distance.coast.matrix,LAT.diff,LONG.diff,Longitude.matrix,Latitude.matrix,
   LONG.matrix.east,LAT.matrix.east,LONG.coast.east,LAT.coast.east,LAT.coast,LONG.coast,
   long.chui,poly,Distance.coast.matrix2,LAT.diff2,LONG.diff2,Longitude.matrix2,Latitude.matrix2)

attach(mammal.data)

#mammal.short.PA<-tapply(rep(1,length(LOCALIDADE)),list(LOCALIDADE,ESPECIE),sum)
#mammal.short.PA[is.na(mammal.short.PA)]<-0

#head(mammal.data)

```


```{r Creating_2x2_degrees_for_the_whole_AF,results='hide',message=FALSE,echo=FALSE,warning=FALSE}

AF.Long<-unlist(lapply((biomes[6,]@polygons)[[1]]@Polygons,function(x)x@coords[,1]))
AF.Lat<-unlist(lapply((biomes[6,]@polygons)[[1]]@Polygons,function(x)x@coords[,2]))

AF.Lat2<-ceiling(c(AF.Lat,Lat)/2)*2-1
AF.Long2<-ceiling(c(AF.Long,Long)/2)*2-1

#Create a dataframe with the unique locations representing the AF (the point 53 is an isolated island))
environment.AF.2d<-unique(data.frame(AF.Long2=AF.Long2,AF.Lat2=AF.Lat2))

```

  We analyzed the data using the original local sampling units and grouping the original data points in 26 2x2 degrees grid cells (Fig. 1). Most localities were surveyed by a single study, then most of the sampling points represent a single study (see data collection). The number of species encountered in each locality (S; alpha diversity), and the similarity in species composition (beta diversity) were used as response variables.
  The similarity in species composition was accessed by calculating the Jaccard similarity index among all pairs of samples. The matrix of similarities was summarized using a Principal Coordinates Analysis (PCoA). We used only the first two ordination axes because all axes in higher dimensions captured alone less than 10% of the variation from the similarity matrix.


``` {r Summarizing local environmental data, results='hide',echo=FALSE,message=FALSE,warning=FALSE}

species.ab.loc<-tapply(rep(1,length(Lat)),list(paste(Long,Lat),ESPECIE),sum)
species.ab.loc[is.na(species.ab.loc)]<-0

species.loc <- species.ab.loc
species.loc[species.loc>0]<-1

environment<-data.frame(unique(cbind(Long,Lat)))
environment<-environment[order(factor(paste(environment[,1],environment[,2]))),]

environment$dist.coast<-tapply(as.numeric(Distance.coast),paste(Long,Lat),mean)
#environment$conservation<-tapply(as.numeric(CONSERVACAO),paste(Long,Lat),mean)
environment$habitat<-tapply(as.numeric(CONSERVACAO),paste(Long,Lat),mean)
environment$vegetation<-tapply(as.numeric(FISIONOMIA),paste(Long,Lat),mean)

###

environment[paste("bio",1:19,sep="")]<-NA

#Take the mean climatic values of four points around the observed area

for(i in 1:nrow(environment)){
  temp.clim<-extract(wclim.clipped,extent(environment[i,1]-.05,environment[i,1]+.05,environment[i,2]-.05,environment[i,2]+.05))
  environment[i,paste("bio",1:19,sep="")]<-colMeans(temp.clim,na.rm=TRUE)}

environment[,paste("PCA.wclim.",1:3,sep="")]<-prcomp(decostand(environment[,paste("bio",1:19,sep="")],"standardize"))$x[,1:3]

# Creating observed statistics

environment$rich<-rowSums(species.loc)
similarity.jac.loc<-vegdist(species.loc,"jaccard")
environment[,paste("pcoa.jac.",1:3,sep="")]<--prcomp(similarity.jac.loc)$x[,1:3]

environment<-data.frame(environment,std=decostand(environment,"standardize"))

geodist.loc<-dist(environment[,c("Lat","Long")])
#envdist.loc<-dist(environment[grep("std",colnames(environment))][c(6,17)]) #using just bio1 and bio12

envdist.loc<-dist(environment[grep("std",colnames(environment))][c(25)])
habdist.loc<-dist(environment[grep("std",colnames(environment))][4])


```

```{r Summarizing environmental data for each quadrant, message=FALSE,results='hide',echo=FALSE,warning=FALSE}

species.2d<-tapply(rep(1,length(Lat2)),list(paste(Long2,Lat2),ESPECIE),sum)
species.2d[is.na(species.2d)]<-0
species.2d[species.2d>0]<-1

environment.2d<-data.frame(unique(cbind(Long2,Lat2)))
environment.2d<-environment.2d[order(factor(paste(environment.2d[,1],environment.2d[,2]))),]

environment.2d$dist.coast<-tapply(as.numeric(Distance.coast2),paste(Long2,Lat2),mean)
#environment.2d$conservation<-tapply(as.numeric(CONSERVACAO),paste(Long2,Lat2),mean)
environment.2d$habitat<-tapply(as.numeric(CONSERVACAO),paste(Long2,Lat2),mean)
environment.2d$vegetation<-tapply(as.numeric(FISIONOMIA),paste(Long2,Lat2),mean)

# r extracting environmental data from worldclim layers, results="hide"}

environment.2d[paste("bio",1:19,sep="")]<-NA

for(i in 1:nrow(environment.2d)){
  temp.clim<-extract(wclim.clipped,extent(environment.2d[i,1]-1,environment.2d[i,1]+1,environment.2d[i,2]-1,environment.2d[i,2]+1))
  environment.2d[i,paste("bio",1:19,sep="")]<-colMeans(temp.clim,na.rm=TRUE)}

environment.2d[,paste("PCA.wclim.",1:3,sep="")]<-prcomp(decostand(environment.2d[,paste("bio",1:19,sep="")],"standardize"))$x[,1:3]

# Creating observed statistics

environment.2d$rich<-rowSums(species.2d)
similarity.jac<-vegdist(species.2d,"jaccard")
environment.2d[,paste("pcoa.jac.",1:3,sep="")]<--prcomp(similarity.jac)$x[,1:3]


#plot(pcoa.jac.1~Lat2,data=environment.2d)

environment.2d<-data.frame(environment.2d,std=decostand(environment.2d,"standardize"))

environment.2d$matchin.AF.2d<-match(paste(environment.2d[,1],environment.2d[,2]),paste(environment.AF.2d[,1],environment.AF.2d[,2]))

geodist.2d<-dist(environment.2d[,c("Lat2","Long2")])
envdist.2d<-dist(environment.2d[grep("std",colnames(environment.2d))][c(25)]) #Using just PCA1 and 2 of wclim var
habdist.2d<-dist(environment.2d[grep("std",colnames(environment.2d))][4]) #Using just PCA1 and 2 of wclim var

```

```{r Fig_1_Study_site, fig.width=8,fig.height=8,echo=FALSE,results='hide',message=FALSE,warning=FALSE}

par(xpd=NA)

#par (new=T)

plot(biomes[6,],col='lightblue',border="0",xlim=c(-45,-38))

#plot(subset(wclim.clipped,"bio1"),add=T)
plot(brazil,add=T,lwd=2)
#plot(biomes[6,],add=T,col=adjustcolor(4,alpha=.2),border=1)

rect(environment.AF.2d$AF.Long2-1,environment.AF.2d$AF.Lat2-1,environment.AF.2d$AF.Long2+1,environment.AF.2d$AF.Lat2+1,col=adjustcolor("darkgrey",alpha=.1),border=adjustcolor("darkgrey",alpha=1))

rect(environment.2d$Long2-1,environment.2d$Lat2-1,environment.2d$Long2+1,environment.2d$Lat2+1,col=adjustcolor("green",alpha=.2),border=adjustcolor("darkgrey",alpha=1))
points(mammal.data$Long,mammal.data$Lat,cex=log(ifelse(is.na(AREA..ha.),100,AREA..ha.)+1)/3,pch=21,bg=adjustcolor(2,alpha=.1),col=0)


range.size<-range(log(ifelse(is.na(AREA..ha.),100,AREA..ha.)+1))
divs=5
sizes<-seq(range.size[1]+(diff(range.size)/divs/2),range.size[2]-(diff(range.size)/divs/2),length=divs)

legend(-30,-5, legend=round(exp(sizes)) , pch = 21, col=0,pt.bg=adjustcolor(2,alpha=.5),pt.cex=sizes/3,y.intersp=exp(seq(log(1.2),log(1.5),length=divs)),x.intersp=3,bty="n")

text(-28,-4,"Area (ha)",cex=2)

#points(Long2,Lat2)
#rect(Long2-1,Lat2-1,Long2+1,Lat2+1,col=adjustcolor(3,alpha=.01))


#text(tapply(Long2+1,paste(Lat2,Long2),min),tapply(Lat2+1,paste(Lat2,Long2),min),
#tapply(Lat2,paste(Lat2,Long2),length),font=2)

#text(tapply(Long2+1,paste(Lat2,Long2),min),tapply(Lat2+1,paste(Lat2,Long2),min),
#tapply(AUTOR.E.ANO,paste(Lat2,Long2),function(x)nlevels(factor(as.character(x)))))

#text(environment.2d$Long2,environment.2d$Lat2,rowSums(species.2d))

```
###### Fig. 1. Map of the Atlantic Forest (AF; blue shade) showing the orinal sampling points (red circles) and the grid cells encompassing the entire AF. The size of the circles represent the size o the original sampling area in the log scale. Green shade represent the grid cells where small mammal data was available. 

####

##### Dispersal-based models

  For estimating the influence of dispersal limitation on species local diversity (S) and turnover (Jaccard index; PCoA1 and PCoA2), we created a network of interconnected grid cells representing the AF. This network was used to determine the flux of species or individuals between grid cells in simulation models (Fig. S2). Two models were used to recreate the species distribution under dispersal alone: the mid domain spreading-dye model (Colwell and Hurtt 1994; Colwell and Lees 2000), and the analytical neutral approach borrowed from the population genetics (Nagylaki, 1980) and presented by Economo & Keitt (2008) for community ecology. These models were created just using the grouped data in grid cells because of the completeness of data, and due to computational limitation.
  In the mid domain spreading dye model, the number of grid cells occupied by each small mammal species was recorded. For each species, one of the 26 grid cells was randomly selected and the species occurrence was spread from the selected cell to neighboring cells until the original number of grid cells was occupied. This procedure was repeated 10,000 times for the `r ncol(species.2d)` species. Each cell had up to eight neighbors (Moore neighborhood; Fig. S2), and the model was bounded by the domain where actual small mammal data was recorded (26 grid cells).


```{r Connectivity 26 and 56, echo=FALSE,message=FALSE,results='hide',warning=FALSE}

#Create a matrix of euclidean distances between all pairs of grid cells
dist.AF.2d<-as.matrix(dist(environment.AF.2d[,1:2]))

#Set as 1 the migration rate when the distance is below 4 and above 2 degrees (all adjacent grid cells, including diagonal but not self loops)

connect.AF.2d<-ifelse(dist.AF.2d<4&dist.AF.2d>0,1,0)
connect.2d<-connect.AF.2d[environment.2d$matchin.AF.2d,environment.2d$matchin.AF.2d]

#rownames(connect.2d)<-1:26

```

```{r Mid-Domain, cache=FALSE,results='hide',echo=FALSE,message=FALSE,warning=FALSE}

reps=999

MidD.sim<-array(NA,dim=c(nrow(connect.2d),ncol(species.2d),reps))

for(i in 1:reps){
  MidD.sim[,,i]<-MidD(connect.2d,colSums(species.2d),simplify=T)
  }

#### Extracting summary statistics

rich.MidD.vec<-apply(MidD.sim,3,rowSums)

similarity.MidD.vec<-apply(MidD.sim,3,function(mat)as.vector(as.matrix(vegdist(mat,"jaccard"))))


similarity.MidD.mean<-matrix(rowMeans(similarity.MidD.vec),nrow(species.2d),nrow(species.2d))

environment.2d$rich.MidD.mean<-rowMeans(rich.MidD.vec)
environment.2d$rich.MidD.sd<-apply(rich.MidD.vec,1,sd)

similarity.MidD.mean<-matrix(rowMeans(similarity.MidD.vec),nrow(species.2d),nrow(species.2d))
similarity.MidD.sd<-matrix(apply(similarity.MidD.vec,1,sd),nrow(species.2d),nrow(species.2d))

environment.2d[,paste("pcoa.MidD.jac.",1:3,sep="")]<-(prcomp(similarity.MidD.mean)$x[,1:3])

#plot(pcoa.jac.1~pcoa.MidD.jac.1,data=environment.2d)

```

  In the neutral model, the whole area comprising the AF was divided in 56 2x2 degrees grid cells from which 26 had small mammal data available (Fig. 1). The model started with a single species occupying all the 56 cells. In each generation, new species were added in each cell by point speciation with rate $\nu$, set the same for al cells (see Economo & Keitt (2010) and Muneepeerakul et al. (2008) for more details and other uses). $\nu$ represents the probability of an individual to become a new species but could also represent the addition of new species by immigration from a larger species pool outside the AF (eg. the Cerrado or Amazonian forests). To recreate the dispersal of individuals, we determined that a cell could just be colonized by a neighbor (Moore neighborhood; Fig S2), and that all grid cells had the same migration rate (parameter $m$). The local community size (number of individuals) was set the same for all grid cells ($N$ = 100). The model was run for multiple generations, until the diversity within (PIE and HillPIE) and between all cells (Morisita-Horn similarity) reached a steady-state (usually more than 30,000 generations).


  Differently from the Mid-domain model, the values of $m$, $\nu$, and $N$ were initially set independently of the observed data. Because different combinations of these parameters can create the same patterns of species distribution (Etienne 2006?; Economo and Keitt 2010), and because estimates for these parameters based on empirical data are not available, we did not attempt to estimate realistic parameters, but focused on the general patterns that the model could produce (see discussion for implications of this procedure). $N$ was arbitrarily defined as 100 individuals for all grid cells, and $m$ and $\nu$ were used as knobs to best fit the model to the observed similarity in species composition. These parameters were simultaneously tunned using the L-BFSG-S optimization algorithm. In summary, $m$ and $\nu$ were adjusted to minimize the differences between the predictions of the neutral model to the observed data, giving the best possible explanation of dispersal to the observed data (this procedure is conceptually analog to a regression analysis using maximum likelihood optimization). Because the number of individuals per grid cell was kept constant during the optimization, the differences in diversity were due to the location of a cell in the network and the number of neighbor grid cells, but not affected by the differences in abundance.

```{r set the number of generations to run, echo=FALSE,results='hide',warning=FALSE,message=FALSE}

nruns=1000

```


```{r Neutral Model - Optimization, cache=TRUE, results='hide',fig.show='hide',echo=FALSE,message=FALSE,warning=FALSE}

#Set initial parameters

m=0.03445190  #migration rate
v=0.00204737  #speciation rate
N=100 #Number of individuals in each node


optimized<-optim(c(m,v),lower=0.001,upper=0.5,method="L-BFGS-B",function(x){
  
M<-connect.AF.2d*(x[1]/rowSums(connect.AF.2d))
M[is.na(M)]<-0

diag(M)<-1-(rowSums(M)-diag(M))

#rowSums(M)

neutral.AF<-anetwork(N,M,x[2],nruns=1000)
F1=neutral.AF$finalF

morisita.AF.2d<-extractMH(neutral.AF$finalF)

resu<-sum((similarity.jac-(1-as.dist(morisita.AF.2d[environment.2d$matchin.AF.2d,environment.2d$matchin.AF.2d])))^2)

  print(resu)
  resu
  
#sum((decostand(prcomp(morisita.AF.2d[environment.2d$matchin.AF.2d,environment.2d$matchin.AF.2d])$x[,1],'range')-
#decostand(environment.2d$pcoa.jac.1,'range'))^2)

  })

```

```{r Neutral Model add run - use optimization parameters, message=FALSE,results='hide',echo=FALSE}

m<-optimized$par[1]
v<-optimized$par[2]

M<-connect.AF.2d*(m/rowSums(connect.AF.2d))
M[is.na(M)]<-0

diag(M)<-1-(rowSums(M)-diag(M))



neutral.AF<-anetwork(N,M,v,nruns=nruns)
F1=neutral.AF$finalF

environment.AF.2d$Hill<-1/(diag(neutral.AF$finalF))
morisita.AF.2d<-extractMH(neutral.AF$finalF)

environment.AF.2d[,paste("pcoa.mor.AF",1:3,sep="")]<-prcomp(as.dist(morisita.AF.2d))$x[,1:3]
environment.AF.2d[,paste("pcoa.mor.",1:3,sep="")]<-environment.AF.2d[,paste("pcoa.mor.AF",1:3,sep="")]*NA

environment.AF.2d[environment.2d$matchin.AF.2d,paste("pcoa.mor.",1:3,sep="")]<-#PCA.AF[,1:3]
  prcomp(morisita.AF.2d[environment.2d$matchin.AF.2d,environment.2d$matchin.AF.2d])$x[,1:3]

#plot(environment.2d$Lat2,1-decostand(environment.2d$pcoa.jac.1,'range'),bg="gold",pch=22)
#points((environment.AF.2d$AF.Lat2),decostand(environment.AF.2d$pcoa.mor.1,'range',na.rm=T),bg=1,pch=21)
#points(environment.2d$Lat2,decostand(environment.2d$pcoa.MidD.jac.1,'range'),bg=2,pch=23)

#plot(decostand(prcomp(morisita.AF.2d[environment.2d$matchin.AF.2d,environment.2d$matchin.AF.2d])$x[,1],'range'),decostand(environment.2d$pcoa.jac.1,'range'))

```

  The model proposed by Economo and Keitt (2008) is probabilistic and does not require the simulation of each individual in the metacommunity, being less computationally intensive. This model allowed us to investigate thoroughly the parameter space of $m$ and $\nu$ to find the best explanatory model to the observed data. However, because the model is based on probabilities, it does not allow one to calculate statistics based on the raw data (eg. the Jaccard similarity index). Because not all original studies recorded species abundances, we compared the Morisita-Horn similarity matrix from the neutral model with the observed Jaccard similarity for optimization. These indexes are usually highly correlated (Chao et al., 2006; Krasnov et al., 2005) and we believe this procedure did not have profound effects on the neutral fit.
  To calculate the Jaccard similarity index from the neutral model, each individual in the metacommunity was simulated using the previously optimized parameters. We run an initial buffer of 30,000 generations. Then the model was run for additional 1000 generations 5,000 times, representing 5,000 simulations. The mean of all the 5,000 simulations was used to calculate the remaining summary statistics (see below). The correlation between the probabilistic and the simulated model was 99.98% when comparing the Morisita-Horn index of pairwise similarity, so we believe the simulations run long enough to capture the final predictions of the neutral model.

```{r neutral_theory_real_simulation, results='hide',message=FALSE,echo=FALSE}

# Might take more than 12 hours to run in a regular computer

N<-matrix(N,nrow(M))

if(file.exists("neutral.sim.ind10k.txt")){
  
  neutral.sim.ind<- read.table("neutral.sim.ind10k.txt",header=TRUE)
  
  }else{
    
    #m=0.01790858  #migration rate
    #v=0.0017789240  #speciation rate
    #N=100 #Number of individuals in each node
    
    reps2<-10000
    initbuffer<-1
    
    sp.abund2<-simunetwork(N,M,v,nruns=initbuffer,simplify=FALSE)
    
    neutral.sim.ind<-matrix(NA,sum(N),reps2)
    
    for(rep in 1:reps2){
      
      sp.abund2<-simunetwork(N,M,v,nruns=nruns-1,simplify=FALSE,sp.abund=sp.abund2)
      
      neutral.sim.ind[,rep]<-sp.abund2
      
      #print(rep)
      }
    
    write.table(neutral.sim.ind,file="neutral.sim.ind10k.txt")
    
    #tapply(rep(1,sum(N)),list(rep(1:length(N),N),neutral.sim.ind[,1]),sum)
    
    }



```

```{r Calculating_statistics_from_neutral_real_simu, message=FALSE, results='hide',echo=FALSE}


similarity.neutral.total<-array(NA,dim=c(nrow(environment.AF.2d),nrow(environment.AF.2d),ncol(neutral.sim.ind)))
similarity.neutral.jac.total<-array(NA,dim=c(nrow(environment.AF.2d),nrow(environment.AF.2d),ncol(neutral.sim.ind)))
similarity.neutral<-array(NA,dim=c(nrow(environment.2d),nrow(environment.2d),ncol(neutral.sim.ind)))
similarity.neutral.jac<-array(NA,dim=c(nrow(environment.2d),nrow(environment.2d),ncol(neutral.sim.ind)))
hill.neutral<-matrix(NA,nrow(environment.AF.2d),ncol(neutral.sim.ind))
rich.neutral<-matrix(NA,nrow(environment.AF.2d),ncol(neutral.sim.ind))

for(i in 1:ncol(neutral.sim.ind)){
  
  ver<-tapply(rep(1,sum(N)),list(rep(1:length(N),N),neutral.sim.ind[,i]),sum)
  ver[is.na(ver)]<-0
  
  similarity.neutral.total[,,i]<-as.matrix(vegdist(ver,"morisita"))
  similarity.neutral.jac.total[,,i]<-as.matrix(vegdist(ver,"jaccard"))
  
  similarity.neutral[,,i]<-as.matrix(vegdist(ver,"morisita"))[environment.2d$matchin.AF.2d,environment.2d$matchin.AF.2d]
  similarity.neutral.jac[,,i]<-as.matrix(vegdist(ver,"jaccard"))[environment.2d$matchin.AF.2d,environment.2d$matchin.AF.2d]
  
  hill.neutral[,i]<-(1/(rowSums((ver/rowSums(ver))^2)*(rowSums(ver)-1)/(rowSums(ver))))
  rich.neutral[,i]<-rowSums(ver>0)
  }

environment.AF.2d$rich.neutral.mean<-rowMeans(rich.neutral)
environment.AF.2d$rich.neutral.sd<-apply(rich.neutral,1,sd)

environment.AF.2d$hill.neutral.mean<-rowMeans(hill.neutral)
environment.AF.2d$hill.neutral.sd<-apply(hill.neutral,1,sd)

environment.AF.2d[,paste("pcoa.mor.neutral.total.",1:3,sep="")]<-environment.AF.2d[,paste("pcoa.mor.AF",1:3,sep="")]*NA

environment.AF.2d[,paste("pcoa.jac.neutral.total.",1:3,sep="")]<-environment.AF.2d[,paste("pcoa.mor.AF",1:3,sep="")]*NA

environment.AF.2d[,paste("pcoa.mor.neutral.",1:3,sep="")]<-environment.AF.2d[,paste("pcoa.mor.AF",1:3,sep="")]*NA

environment.AF.2d[,paste("pcoa.jac.neutral.",1:3,sep="")]<-environment.AF.2d[,paste("pcoa.mor.AF",1:3,sep="")]*NA


environment.AF.2d[,paste("pcoa.mor.neutral.total.",1:3,sep="")]<-#PCA.AF[,1:3]
  prcomp(apply(similarity.neutral.total[,,round(.6*ncol(neutral.sim.ind)):ncol(neutral.sim.ind)],2,function(x)rowMeans(x)))$x[,1:3]

environment.AF.2d[,paste("pcoa.jac.neutral.total.",1:3,sep="")]<-#PCA.AF[,1:3]
  -prcomp(apply(similarity.neutral.jac.total[,,round(.6*ncol(neutral.sim.ind)):ncol(neutral.sim.ind)],2,function(x)rowMeans(x)))$x[,1:3]

similarity.neutral.mean<-apply(similarity.neutral[,,round(.6*ncol(neutral.sim.ind)):ncol(neutral.sim.ind)],2,function(x)rowMeans(x))

environment.AF.2d[environment.2d$matchin.AF.2d,paste("pcoa.mor.neutral.",1:3,sep="")]<-#PCA.AF[,1:3]
  prcomp(similarity.neutral.mean)$x[,1:3]

similarity.neutral.jac.mean<-apply(similarity.neutral.jac[,,round(.6*ncol(neutral.sim.ind)):ncol(neutral.sim.ind)],2,function(x)rowMeans(x))

environment.AF.2d[environment.2d$matchin.AF.2d,paste("pcoa.jac.neutral.",1:3,sep="")]<-#PCA.AF[,1:3]
  -prcomp(similarity.neutral.jac.mean)$x[,1:3]

#cor(environment.AF.2d$pcoa.mor.1,environment.AF.2d$pcoa.mor.neutral.1,use="c")


```

##### Deterministic models - Environmental effects

To test the association of the species diversity with the climatic and habitat quality variables, individual logistic regressions were fit for all species against these predictor variables, allowing each species to vary independently of one another.

```{r logistic_regression_of_each_species, warning=FALSE, echo=FALSE}

glm.results.2d<-list()
bysp.glm.results.2d<-list()

glm.coef.2d<-list()
bysp.glm.coef.2d<-matrix(NA,ncol(species.2d),2,dimnames=list(colnames(species.2d),c('a','b')))

#glm.variables.2d<-c("Long2","Lat2","conservation","vegetation",paste("bio",1:19,sep=""),"PCA.wclim.1","PCA.wclim.2")
glm.variables.2d<-c("Long2","Lat2","habitat","vegetation",paste("bio",1:19,sep=""),"PCA.wclim.1","PCA.wclim.2")

for(k in glm.variables.2d){
  for(i in colnames(species.2d)){
    
    bysp.glm.results.2d[[i]]<-glm(as.formula(paste('species.2d[,i]~',paste(k))),family=binomial,data=environment.2d)
    bysp.glm.coef.2d[i,]<-coefficients(bysp.glm.results.2d[[i]])
    
    }
  glm.coef.2d[[k]]<-list(bysp.glm.coef.2d,environment.2d[k])
  }


#Estimate the probability of occurrence for each species in each site given the environmental variables

probs.2d<-lapply(glm.coef.2d,function(x){(exp(x[[1]][,1]+x[[1]][,2]%*%t(x[[2]])))/(1+exp(x[[1]][,1]+x[[1]][,2]%*%t(x[[2]])))}) 


```

 The probability of occurrence generated by the logistic model for each species was summed to estimate the expected number of species in each quadrant:
  
$$
\hat S_i = \sum_{j=1}^{S}{\frac{e^{X_i\beta_j}}{1+e^{X_i\beta_j}}}
$$
  
Where $X_i$ denotes a vector of the environmental variables in the quadrant $i$, and $\beta_j$ is a vector with the coefficients from the logistic regression for the species $j$.

```{r extract predictions of the logistic curve, echo=FALSE, results='hide',warning=FALSE}

Hill.logis<-data.frame(Hill.logis=lapply(probs.2d,function(x)1/(1-(colSums((x/colSums(x))^2)))))
rich.logis<-data.frame(rich.logis=lapply(probs.2d,function(x)colSums(x)))

environment.AF.2d[,as.character(colnames(Hill.logis))]<-NA
environment.AF.2d[,as.character(colnames(rich.logis))]<-NA

environment.AF.2d[environment.2d$matchin.AF.2d,colnames(Hill.logis)]<-Hill.logis
environment.AF.2d[environment.2d$matchin.AF.2d,colnames(rich.logis)]<-rich.logis

```

To calculate the raw statistics based on these probabilities, the distribution of each species was simulated based on the probabilities of occurrence generated by the logistic curve, similarly to what was done for the neutral model. For each species, the number of grid cells where the species was observed was counted. The model spread each species into the map based on its probability of occurrence until the number of grid cells occupied in the simulation matched the number observed. This allowed each species to vary independently, and to the relationship between the environmental variables and the response variables (eg. number of species) to be non-linear. Differently from the non-linearities that could be used in other statistical tests, such as Generalized Additive Models, the deterministic part of this model has an underlying mechanistic function (logistic). Note that this model does not require the species to have continuous ranges as in the mid domain model.


```{r logistic simulation and extract predictions, echo=FALSE,results='hide',warning=FALSE}

#### Simulate the distribution of individuals using the probabilities and then extract the jaccard index

reps=999

similarity.logis.jac<-array(NA,dim=c(nrow(environment.2d),nrow(environment.2d),reps))

species.2d.logis.ls<-list()
similarity.logis.jac.ls<-list()
  
for(j in glm.variables.2d){
  
#  j=glm.variables.2d[[25]]
 
  species.2d.logis.reps<-list()
  
  for(k in 1:reps){

  species.2d.logis<-species.2d*0

    for(i in 1:ncol(species.2d.logis)){
      
      species.2d.logis[sample(nrow(species.2d.logis),sum(species.2d[,i]),prob=probs.2d[[j]][i,]),i]<-1
      
      }
    
    similarity.logis.jac[,,k]<-as.matrix(vegdist(species.2d.logis,"jaccard"))
    species.2d.logis.reps[[k]]<-species.2d.logis

    }
  
  similarity.logis.jac.ls[[j]]<-similarity.logis.jac
  species.2d.logis.ls[[j]]<-species.2d.logis.reps
    
  environment.AF.2d[,paste("pcoa.logis.jac.",j,".",1:3,sep="")]<-NA
  
  environment.AF.2d[environment.2d$matchin.AF.2d,paste("pcoa.logis.jac.",j,".",1:3,sep="")]<-
    prcomp(apply(similarity.logis.jac,2,rowMeans))$x[,1:3]
  
  }


```

```{r binding_all_data_frames, echo=FALSE,results='hide',warning=FALSE}

environment.AF.2d[,colnames(environment.2d)]<-NA
environment.AF.2d[environment.2d$match,colnames(environment.2d)]<-environment.2d
```

##### Model Comparisons

We compared the three simulation models (Mid Domain, Neutral, and based on logistic regressions) by their Mean Square Error (MSE; Gotelli et al. 2009). The MSE was calculated as the sum of the squared bias and model variance, so the MSE is a balance between precision and accuracy (see Gotelli et al. 2009 and Appendix S3 for detailed description).

```{r MSE richness,echo=FALSE,results='hide',warning=FALSE}

O<-environment.2d[!is.na(environment.2d[,"rich"]),"rich"]

S<-rich.MidD.vec
E<-rowMeans(S)

s.bias.sq.MidD<-sum((O-E)^2)
s.var.MidD<-(sum(colSums((S-E)^2)))/(ncol(S)-1)
s.mse.MidD = s.bias.sq.MidD + s.var.MidD

S<-rich.neutral[!is.na(environment.AF.2d[,"rich"]),]
E<-rowMeans(S)

s.bias.sq.neutral<-sum((O-E)^2)
s.var.neutral<-(sum(colSums((S-E)^2)))/(ncol(S)-1)
s.mse.neutral = s.bias.sq.neutral + s.var.neutral

s.bias.sq.logis<-{}
s.var.logis<-{}
s.mse.logis = {}

for (i in glm.variables.2d){ 

S<- do.call(cbind,lapply(species.2d.logis.ls[[i]],rowSums))

E<-rowMeans(S)

s.bias.sq.logis[i]<-sum((O-E)^2)
s.var.logis[i]<-(sum(colSums((S-E)^2)))/(ncol(S)-1)
s.mse.logis[i] = s.bias.sq.logis[i] + s.var.logis[i]

}

```

```{r MSE composition,echo=FALSE,results='hide',warning=FALSE}

## Composition first and second axes

O<-environment.2d$pcoa.jac.1

S<-apply(similarity.MidD.vec,2,function(x){prcomp(matrix(x,26,26))$x[,1]})
E<-rowMeans(S)

s.bias.sq.MidD.c1<-sum((O-E)^2)/2
s.var.MidD.c1<-(sum(colSums((S-E)^2)))/(ncol(S)-1)/2
s.mse.MidD.c1 = s.bias.sq.MidD.c1 + s.var.MidD.c1

S<-apply(similarity.neutral,3,function(x){prcomp(x)$x[,1]})
E<-rowMeans(S)
#E2<-prcomp((1-morisita.AF.2d[environment.2d$matchin.AF.2d,environment.2d$matchin.AF.2d]))$x[,1] ### CHANGE

s.bias.sq.neu.c1<-sum((O-E)^2)/2
s.var.neu.c1<-(sum(colSums((S-E)^2)))/(ncol(S)-1)/2
s.mse.neu.c1 <- s.bias.sq.neu.c1 + s.var.neu.c1

s.bias.sq.logis.c1<-{}
s.var.logis.c1<-{}
s.mse.logis.c1<- {}

for (i in glm.variables.2d){ 
  
S<-apply(similarity.logis.jac.ls[[i]],3,function(x){prcomp(x)$x[,1]})
E<-rowMeans(S)
  
s.bias.sq.logis.c1[i]<-sum((O-E)^2)/2
s.var.logis.c1[i]<-(sum(colSums((S-E)^2)))/(ncol(S)-1)/2
s.mse.logis.c1[i] = s.bias.sq.logis.c1[i] + s.var.logis.c1[i]

}

#second

O<-environment.2d$pcoa.jac.2

S<-apply(similarity.MidD.vec,2,function(x){prcomp(matrix(x,26,26))$x[,2]})
E<-rowMeans(S)

s.bias.sq.MidD.c2<-sum((O-E)^2)/2
s.var.MidD.c2<-(sum(colSums((S-E)^2)))/(ncol(S)-1)/2
s.mse.MidD.c2 = s.bias.sq.MidD.c2 + s.var.MidD.c2

S<-apply(similarity.neutral,3,function(x){prcomp(x)$x[,2]})
E<-rowMeans(S)
#E2<-prcomp((1-morisita.AF.2d[environment.2d$matchin.AF.2d,environment.2d$matchin.AF.2d]))$x[,1] ### CHANGE

s.bias.sq.neu.c2<-sum((O-E)^2)/2
s.var.neu.c2<-(sum(colSums((S-E)^2)))/(ncol(S)-1)/2
s.mse.neu.c2 <- s.bias.sq.neu.c2 + s.var.neu.c2

s.bias.sq.logis.c2<-{}
s.var.logis.c2<-{}
s.mse.logis.c2<- {}

for (i in glm.variables.2d){ 
  
S<-apply(similarity.logis.jac.ls[[i]],3,function(x){prcomp(x)$x[,2]})
E<-rowMeans(S)
  
s.bias.sq.logis.c2[i]<-sum((O-E)^2)/2
s.var.logis.c2[i]<-(sum(colSums((S-E)^2)))/(ncol(S)-1)/2
s.mse.logis.c2[i] = s.bias.sq.logis.c2[i] + s.var.logis.c2[i]

}




## jac matrix

O<-as.vector(as.matrix(similarity.jac))

S<-similarity.MidD.vec
E<-rowMeans(S)

s.bias.sq.MidD.jac<-sum((O-E)^2)/2
s.var.MidD.jac<-(sum(colSums((S-E)^2)))/(ncol(S)-1)/2
s.mse.MidD.jac = s.bias.sq.MidD.jac + s.var.MidD.jac

S<-apply(similarity.neutral,3,as.vector)
E<-rowMeans(S)
E<-as.vector(1-morisita.AF.2d[environment.2d$matchin.AF.2d,environment.2d$matchin.AF.2d]) ### CHANGE

s.bias.sq.neu.jac<-sum((O-E)^2)/2
s.var.neu.jac<-(sum(colSums((S-E)^2)))/(ncol(S)-1)/2
s.mse.neu.jac <- s.bias.sq.neu.jac + s.var.neu.jac

s.bias.sq.logis.jac<-{}
s.var.logis.jac<-{}
s.mse.logis.jac<- {}

for (i in glm.variables.2d){ 
  
S<-apply(similarity.logis.jac.ls[[i]],3,as.vector)
E<-rowMeans(S)
  
s.bias.sq.logis.jac[i]<-sum((O-E)^2)/2
s.var.logis.jac[i]<-(sum(colSums((S-E)^2)))/(ncol(S)-1)/2
s.mse.logis.jac[i] = s.bias.sq.logis.jac[i] + s.var.logis.jac[i]

}

```

Alternatively, we tested for the direct association of the response variables against the environmental predictors and present these results as supplements. For this test, linear regression models (OLS) were fit for species richness and the two ordination axes of species composition. For the original sampling units, the OLS models had the climatic and habitat quality variables as predictors. For the grouped data, we created three sets of models: (1) Using just the climatic and habitat quality variables as predictors; (2) using just the neutral and mid domain models as predictors; (3) using the neutral and mid domain predictions as predictor variables along with the climatic and habitat quality variables, as suggested by Letten et al. (2013); and (4) using the neutral and mid domain predictions as null hypotheses, and testing for the association of residuals with the climatic and habitat quality variables. Both the raw environmental variables and the prediction from the logistic simulations were used as predictor variables. This gave a total of 20 models (REnv; Neutral; MidD; REnv+Neutral; REnv+MidD; LEnv; REnv+Neutral; REnv+MidD; ResNeutral+Env;  ResMidD+Env; Table 2; Table 4). We assumed normality in the residuals of all models. The models were compared by their AIC values.
  The regression coefficients were set to 1 for the neutral, mid domain, and logistic simulation predictors, so this parameter was not allowed to vary. We did not include an intercept in the models using only these variables as predictors as well, then there were no extra coefficients to be estimated besides the standard deviation in the residuals (one extra parameter). Note however that an intercept and slope were calculated for each species in the logistic models. These extra parameters are added as penalties for the AIC calculations.

```{r regresions local scale, echo=FALSE, results='hide',warning=FALSE}

#library(vegan)

MR1.1.loc<-glm(rich~PCA.wclim.1,data=decostand(environment,"standardize"))

MC1.1.loc<-glm(pcoa.jac.1~PCA.wclim.1,data=decostand(environment,"standardize"))

MC2.1.loc<-glm(pcoa.jac.2~PCA.wclim.1,data=decostand(environment,"standardize"))

#MR1.11.loc<-glm(rich~conservation,data=decostand(environment,"standardize"))
MR1.11.loc<-glm(rich~habitat,data=decostand(environment,"standardize"))

#MC1.11.loc<-glm(pcoa.jac.1~conservation,data=decostand(environment,"standardize"))
MC1.11.loc<-glm(pcoa.jac.1~habitat,data=decostand(environment,"standardize"))

#MC2.11.loc<-glm(pcoa.jac.2~conservation,data=decostand(environment,"standardize"))
MC2.11.loc<-glm(pcoa.jac.2~habitat,data=decostand(environment,"standardize"))

```

  
```{r regressions, echo=FALSE, results='hide',warning=FALSE}

MR1.1<-glm(rich~PCA.wclim.1,data=decostand(environment.AF.2d,"standardize"))

MR1.2<-update(MR1.1,~.+offset(1*rich.neutral.mean)) #Fixed slope for neutral and mid-d
MR1.3<-update(MR1.1,~.+offset(1*rich.MidD.mean))

MR1.4<-update(MR1.1,~0+offset(1*rich.neutral.mean)) #No intercept for these models
MR1.5<-update(MR1.1,~0+offset(1*rich.MidD.mean))

MR1.6<-glm(MR1.4$residuals[environment.AF.2d$Lat2!=100]~PCA.wclim.1,data=decostand(environment.AF.2d,"standardize"))
MR1.7<-glm(MR1.5$residuals[environment.AF.2d$Lat2!=100]~PCA.wclim.1,data=decostand(environment.AF.2d,"standardize"))

MR1.8<-glm(rich~0+rich.logis.PCA.wclim.1,data=decostand(environment.AF.2d,"standardize"))

MR1.9<-update(MR1.8,~.+offset(1*rich.neutral.mean))
MR1.10<-update(MR1.8,~.+offset(1*rich.MidD.mean))

# MR1.11<-glm(rich~conservation,data=decostand(environment.AF.2d,"standardize"))
# 
# MR1.12<-update(MR1.11,~.+offset(1*rich.neutral.mean)) #Fixed slope for neutral and mid-d
# MR1.13<-update(MR1.11,~.+offset(1*rich.MidD.mean))
# 
# MR1.16<-glm(MR1.4$residuals[environment.AF.2d$Lat2!=100]~conservation,data=decostand(environment.AF.2d,"standardize"))
# MR1.17<-glm(MR1.5$residuals[environment.AF.2d$Lat2!=100]~conservation,data=decostand(environment.AF.2d,"standardize"))
# 
# MR1.18<-glm(rich~0+rich.logis.conservation+rich.logis.conservation,data=decostand(environment.AF.2d,"standardize"))
# 
# MR1.19<-update(MR1.18,~.+offset(1*rich.neutral.mean))
# MR1.20<-update(MR1.18,~.+offset(1*rich.MidD.mean))

MR1.11<-glm(rich~habitat,data=decostand(environment.AF.2d,"standardize"))

MR1.12<-update(MR1.11,~.+offset(1*rich.neutral.mean)) #Fixed slope for neutral and mid-d
MR1.13<-update(MR1.11,~.+offset(1*rich.MidD.mean))

MR1.16<-glm(MR1.4$residuals[environment.AF.2d$Lat2!=100]~habitat,data=decostand(environment.AF.2d,"standardize"))
MR1.17<-glm(MR1.5$residuals[environment.AF.2d$Lat2!=100]~habitat,data=decostand(environment.AF.2d,"standardize"))

MR1.18<-glm(rich~0+rich.logis.habitat+rich.logis.habitat,data=decostand(environment.AF.2d,"standardize"))

MR1.19<-update(MR1.18,~.+offset(1*rich.neutral.mean))
MR1.20<-update(MR1.18,~.+offset(1*rich.MidD.mean))



##### Composition


MC1.1<-glm(pcoa.jac.1~std.PCA.wclim.1,data=decostand(environment.AF.2d,"standardize"))

MC1.2<-update(MC1.1,~.+offset(-1*pcoa.jac.neutral.1)) # Change direction
MC1.3<-update(MC1.1,~.+offset(1*pcoa.MidD.jac.1))

MC1.4<-update(MC1.1,~0+offset(-1*pcoa.jac.neutral.1)) # Change direction
MC1.5<-update(MC1.1,~0+offset(1*pcoa.MidD.jac.1))

MC1.6<-glm(MC1.4$residuals[environment.AF.2d$Lat2!=100]~PCA.wclim.1,data=decostand(environment.AF.2d,"standardize"))
MC1.7<-glm(MC1.5$residuals[environment.AF.2d$Lat2!=100]~PCA.wclim.1,data=decostand(environment.AF.2d,"standardize"))

MC1.8<-glm(pcoa.jac.1~0+pcoa.logis.jac.PCA.wclim.1.1,data=decostand(environment.AF.2d,"standardize"))

MC1.9<-update(MC1.8,~.+offset(-1*pcoa.jac.neutral.1))
MC1.10<-update(MC1.8,~.+offset(1*pcoa.MidD.jac.1))

# MC1.11<-glm(pcoa.jac.1~conservation,data=decostand(environment.AF.2d,"standardize"))
# 
# MC1.12<-update(MC1.11,~.+offset(-1*pcoa.jac.neutral.1)) # Change direction
# MC1.13<-update(MC1.11,~.+offset(1*pcoa.MidD.jac.1))
# 
# MC1.16<-glm(MC1.4$residuals[environment.AF.2d$Lat2!=100]~conservation,data=decostand(environment.AF.2d,"standardize"))
# MC1.17<-glm(MC1.5$residuals[environment.AF.2d$Lat2!=100]~conservation,data=decostand(environment.AF.2d,"standardize"))
# 
# MC1.18<-glm(pcoa.jac.1~0+pcoa.logis.jac.conservation.1,data=decostand(environment.AF.2d,"standardize"))
# 
# MC1.19<-update(MC1.18,~.+offset(-1*pcoa.jac.neutral.1))
# MC1.20<-update(MC1.18,~.+offset(1*pcoa.MidD.jac.1))

MC1.11<-glm(pcoa.jac.1~habitat,data=decostand(environment.AF.2d,"standardize"))

MC1.12<-update(MC1.11,~.+offset(-1*pcoa.jac.neutral.1)) # Change direction
MC1.13<-update(MC1.11,~.+offset(1*pcoa.MidD.jac.1))

MC1.16<-glm(MC1.4$residuals[environment.AF.2d$Lat2!=100]~habitat,data=decostand(environment.AF.2d,"standardize"))
MC1.17<-glm(MC1.5$residuals[environment.AF.2d$Lat2!=100]~habitat,data=decostand(environment.AF.2d,"standardize"))

MC1.18<-glm(pcoa.jac.1~0+pcoa.logis.jac.habitat.1,data=decostand(environment.AF.2d,"standardize"))

MC1.19<-update(MC1.18,~.+offset(-1*pcoa.jac.neutral.1))
MC1.20<-update(MC1.18,~.+offset(1*pcoa.MidD.jac.1))



#####

MC2.1<-glm(pcoa.jac.2~PCA.wclim.1,data=decostand(environment.AF.2d,"standardize"))

MC2.2<-update(MC2.1,~.+offset(1*pcoa.jac.neutral.2)) # Change direction
MC2.3<-update(MC2.1,~.+offset(1*pcoa.MidD.jac.2))

MC2.4<-update(MC2.1,~0+offset(1*pcoa.jac.neutral.2)) # Change direction
MC2.5<-update(MC2.1,~0+offset(1*pcoa.MidD.jac.2))

MC2.6<-glm(MC2.4$residuals[environment.AF.2d$Lat2!=0]~PCA.wclim.1,data=decostand(environment.AF.2d,"standardize"))

MC2.7<-glm(MC2.5$residuals[environment.AF.2d$Lat2!=0]~PCA.wclim.1,data=decostand(environment.AF.2d,"standardize"))

MC2.8<-glm(pcoa.jac.2~0+pcoa.logis.jac.PCA.wclim.1.2,data=decostand(environment.AF.2d,"standardize"))

MC2.9<-update(MC2.8,~.+offset(1*pcoa.jac.neutral.2))
MC2.10<-update(MC2.8,~.+offset(1*pcoa.MidD.jac.2))

# MC2.11<-glm(pcoa.jac.2~conservation,data=decostand(environment.AF.2d,"standardize"))
# 
# MC2.12<-update(MC2.1,~.+offset(1*pcoa.jac.neutral.2)) # Change direction
# MC2.13<-update(MC2.1,~.+offset(1*pcoa.MidD.jac.2))
# 
# MC2.16<-glm(MC2.4$residuals[environment.AF.2d$Lat2!=0]~conservation,data=decostand(environment.AF.2d,"standardize"))
# 
# MC2.17<-glm(MC2.5$residuals[environment.AF.2d$Lat2!=0]~conservation,data=decostand(environment.AF.2d,"standardize"))
# 
# MC2.18<-glm(pcoa.jac.2~0+pcoa.logis.jac.conservation.2,data=decostand(environment.AF.2d,"standardize"))
# 
# MC2.19<-update(MC2.18,~.+offset(1*pcoa.jac.neutral.2))
# MC2.20<-update(MC2.18,~.+offset(1*pcoa.MidD.jac.2))


MC2.11<-glm(pcoa.jac.2~habitat,data=decostand(environment.AF.2d,"standardize"))

MC2.12<-update(MC2.1,~.+offset(1*pcoa.jac.neutral.2)) # Change direction
MC2.13<-update(MC2.1,~.+offset(1*pcoa.MidD.jac.2))

MC2.16<-glm(MC2.4$residuals[environment.AF.2d$Lat2!=0]~habitat,data=decostand(environment.AF.2d,"standardize"))

MC2.17<-glm(MC2.5$residuals[environment.AF.2d$Lat2!=0]~habitat,data=decostand(environment.AF.2d,"standardize"))

MC2.18<-glm(pcoa.jac.2~0+pcoa.logis.jac.habitat.2,data=decostand(environment.AF.2d,"standardize"))

MC2.19<-update(MC2.18,~.+offset(1*pcoa.jac.neutral.2))
MC2.20<-update(MC2.18,~.+offset(1*pcoa.MidD.jac.2))

```

##### Distance-decay analyses

  Finally, we tested for patterns of distance-decay in the species similarity using simple and partial Mantel tests correlating the matrix of Jaccard similarity (M) to the geographical distance (D), and environmental dissimilarity (E) matrices (Euclidean distance) (see Thompson and Townsend 2006 for a similar approach). Legendre et al. (2005) and Tuomisto and Ruokolainen (2006; 2008) suggest using multiple regression on similarity matrices to separate the effects of niche and neutral processes. However, there is a strong debate about the validity of these models (Legendre et al. 2008; Tuomisto and Ruokolainen 2008). Some authors also suggest using partial Redundancy Analysis (Borcard et al. 1992) for this purpose (Gilbert and Lechowicz 2004), but this method also has serious limitations (Smith and Lundholm 2010). We preferred to base our discussion on the mantel tests and multiple regressions using the summarized data (each grid cell as a unit), as described above. We used (simple) generalized linear models (GLMs) with log links to estimate the relationship between the similarity in species composition and geographical or environmental distances (Millar et al. 2011). Because the Jaccard similarity is a proportion (proportion of shared species), the error of this model was fit with a binomial distribution (Millar et al. 2011). The R-squares of the GLMs was calculated by using the McFadden's apporach (McFadden 1974).


```{r mantel tests - local, message=FALSE,echo=FALSE,results='hide',warning=FALSE}

man.geo.loc<-mantel(similarity.jac.loc,geodist.loc)
man.env.loc<-mantel(similarity.jac.loc,envdist.loc)
man.hab.loc<-mantel(similarity.jac.loc,habdist.loc)

pman.geo.loc<-mantel.partial(similarity.jac.loc,geodist.loc,envdist.loc)
pman.env.loc<-mantel.partial(similarity.jac.loc,envdist.loc,geodist.loc)
pman.hab.loc<-mantel.partial(similarity.jac.loc,habdist.loc,geodist.loc)

#summary(rda.loc<-rda(species.loc,environment[grep("std",colnames(environment))][3:24],environment[,c("Lat","Long")]))

#anova(rda.loc)

```


```{r mantel tests - 2d, message=FALSE,results='hide',echo=FALSE,warning=FALSE}

man.geo.2d<-mantel(similarity.jac,geodist.2d)
man.env.2d<-mantel(similarity.jac,envdist.2d)
man.hab.2d<-mantel(similarity.jac,habdist.2d)

pman.geo.2d<-mantel.partial(similarity.jac,geodist.2d,envdist.2d)
pman.env.2d<-mantel.partial(similarity.jac,envdist.2d,geodist.2d)
pman.hab.2d<-mantel.partial(similarity.jac,envdist.2d,habdist.2d)

```

``` {r using multiple regression in similarity matrices,  message=FALSE,results='hide',echo=FALSE,warning=FALSE}

MS1.0<-glm((1-similarity.jac)~geodist.2d,family = binomial(link=log))

MS1.1<-glm((1-similarity.jac)~envdist.2d,family = binomial(link=log))

#sum((1-similarity.jac)-(MS1.1$fitted.values+resid(MS1.1,type="response")))

neutral.s<-as.dist(morisita.AF.2d[environment.2d$matchin.AF.2d,environment.2d$matchin.AF.2d])

MS1.4<-glm((1-similarity.jac)~0+offset(1*neutral.s))
MS1.5<-glm((1-similarity.jac)~0+offset(1*as.dist(1-similarity.MidD.mean)))

MS1.11<-glm((1-similarity.jac)~habdist.2d,family = binomial(link=log))

```

  All the analyses were conducted in the R program (R Development Core Team, 2013). The models and most of the summary statistics calculations were implemented by the authors, and are available as a supplementary material (see Appendix SXX). We used the packages vegan (Oksanen et al., 2008) for the remaining analyses.

  	
### Results

  All the models had a very poor fit to species richness (Table 1; Fig. 2; Fig. S2). The model with the lowest mean square error and bias was the logistic simulation using habitat quality as a predictor of species presence (Table 1). The model with the lowest variance was the neutral model, but the difference among the models was much smaller than for the bias (Table 1).

Similarly, the regression model with the highest explained variance was the logistic model against habitat quality (Table 1). However, this model have one of the highest AICs due to the high number of parameters estimated. The remaining models explained less than 10% of the variation in species richness (Table 1).
  Besides the poor fit for the data, the Mid Domain and Neutral models created the well known richness peak in the central areas of the Atlantic forest (Fig. 2).
  In the small grain (original sampling units), the habitat quality and climatic variables were able to explain `r round(cor(MR1.1.loc$fitted.values+MR1.1.loc$residuals,MR1.1.loc$fitted.values)^2*100,0)`% and `r round(cor(MR1.11.loc$fitted.values+MR1.11.loc$residuals,MR1.11.loc$fitted.values)^2*100,0)`% of the variation in species richness.


###### Table 1. AIC values comparing the 10 regression models tested for species Richness. MR1.1: Environmental variables as predictors; MR1.2: Environmental variables + Neutral as predictors; MR1.3: Environmental variables + Mid Domain as predictors; MR1.4: Neutral; MR1.5: Mid Domain; MR1.6: Environmental variables as predictors of residuals from Neutral; MR1.7:  Environmental variables as predictors of residuals from Mid Domain; MR1.8: Logistic models as predictors; MR1.9: Logistic model + Neutral as predictors; MR1.10: Logistic model + Mid Domain as predictors.


####

```{r Tab1_AICs richness, echo=FALSE, results='asis'}

npar=c(4,6,4,3,1,6,4,65,67,65,3,5,3,5,3,65,67,65)

logLik<-unlist(lapply(list(MR1.1,MR1.2,MR1.3,MR1.4,MR1.5,MR1.6,MR1.7,MR1.8,MR1.9,MR1.10,MR1.11,MR1.12,MR1.13,MR1.16,MR1.17,MR1.18,MR1.19,MR1.20),logLik))

rsquares<-unlist(lapply(list(MR1.1,MR1.2,MR1.3,MR1.4,MR1.5,MR1.6,MR1.7,MR1.8,MR1.9,MR1.10,MR1.11,MR1.12,MR1.13,MR1.16,MR1.17,MR1.18,MR1.19,MR1.20),function(x)cor(x$fitted.values+x$residuals,x$fitted.values)^2))


BIASsq<-rep(NA,18)
VAR<-rep(NA,18)

BIASsq[c(5,4,8,16)]<-c(MidD=s.bias.sq.MidD,Neutral=s.bias.sq.neutral,s.bias.sq.logis[c(24,3)])
VAR[c(5,4,8,16)]<-c(MidD=s.var.MidD,Neutral=s.var.neutral,s.var.logis[c(24,3)])

print(xtable(
data.frame(modeln=strsplit("MR1.1,MR1.2,MR1.3,MR1.4,MR1.5,MR1.6,MR1.7,MR1.8,MR1.9,MR1.10,MR1.11,MR1.12,MR1.13,MR1.16,MR1.17,MR1.18,MR1.19,MR1.20",",")[[1]],Model=c("rawClim","rawClim+Neu","rawClim+Mid","Neutral","Mid domain","ResN~rawClim","ResN~rawClim","Cimatic","Climatic+Neu","Climatic+Mid","rawHab","rawHab+Neu","rawHab+Mid","ResN~rawHab","ResN~rawHab","Habitat","Habitat+Neu","Habitat+Mid"),logLik=logLik,npar=npar,AIC=-2*logLik+2*npar,rsquares=rsquares,BIASsq=BIASsq,VAR=VAR,MSE=BIASsq+VAR)[c(8,16,5,4),-1]
),type=table.type,html.table.attributes="border=1, bgcolor=#989898",comment=FALSE)

write.csv(
data.frame(modeln=strsplit("MR1.1,MR1.2,MR1.3,MR1.4,MR1.5,MR1.6,MR1.7,MR1.8,MR1.9,MR1.10,MR1.11,MR1.12,MR1.13,MR1.16,MR1.17,MR1.18,MR1.19,MR1.20",",")[[1]],Model=c("rawClim","rawClim+Neu","rawClim+Mid","Neutral","Mid domain","ResN~rawClim","ResN~rawClim","Cimatic","Climatic+Neu","Climatic+Mid","rawHab","rawHab+Neu","rawHab+Mid","ResN~rawHab","ResN~rawHab","Habitat","Habitat+Neu","Habitat+Mid"),logLik=logLik,npar=npar,AIC=-2*logLik+2*npar,rsquares=rsquares,BIASsq=BIASsq,VAR=VAR,MSE=BIASsq+VAR)[c(8,16,5,4),-1]
,"Table_1.csv")


```

###


```{r Fig_2_Map_Richness_Mid_Domain_vs_Neutral,fig.width=18,fig.height=9,echo=FALSE,message=FALSE,results='hide',warning=FALSE}

par(mfrow=c(1,2))

plot(brazil)
rect(environment.2d$Long2-1,environment.2d$Lat2-1,environment.2d$Long2+1,environment.2d$Lat2+1,
     col=adjustcolor(color.select(environment.2d$rich,palette=Custom.Palette),alpha=.8))
title("A)",cex.main=3,adj=0)
title(main="Observed",line=-15,cex.main=3)

plot(brazil)
rect(environment.AF.2d$Long2-1,environment.AF.2d$Lat2-1,environment.AF.2d$Long2+1,environment.AF.2d$Lat2+1,
     col=adjustcolor(color.select(predict(MR1.8,newdata=decostand(environment.AF.2d,"standardize"))
,palette=Custom.Palette),alpha=.8))
title("B)",cex.main=3,adj=0)
title(main="Climatic",line=-15,cex.main=3)


plot(brazil)
rect(environment.AF.2d$Long2-1,environment.AF.2d$Lat2-1,environment.AF.2d$Long2+1,environment.AF.2d$Lat2+1,
     col=adjustcolor(color.select(predict(MR1.18,newdata=decostand(environment.AF.2d,"standardize"))
,palette=Custom.Palette),alpha=.8))
title("C)",cex.main=3,adj=0)
title(main="Habitat",line=-15,cex.main=3)


plot(brazil)
rect(environment.2d$Long2-1,environment.2d$Lat2-1,environment.2d$Long2+1,environment.2d$Lat2+1,
     col=adjustcolor(color.select(environment.2d$rich.MidD.mean,palette=Custom.Palette),alpha=.8))

title("D)",cex.main=3,adj=0)
title(main="Mid Domain",line=-15,cex.main=3)

plot(brazil)
rect(environment.AF.2d$AF.Long2-1,environment.AF.2d$AF.Lat2-1,environment.AF.2d$AF.Long2+1,environment.AF.2d$AF.Lat2+1,
     col=adjustcolor(color.select(environment.AF.2d$rich.neutral.mean*(environment.AF.2d$rich*0+1),ref=environment.AF.2d$rich.neutral.mean*environment.AF.2d$Long2/environment.AF.2d$Long2,palette=Custom.Palette),alpha=.8))

#rect(environment.AF.2d$AF.Long2-1,environment.AF.2d$AF.Lat2-1,environment.AF.2d$AF.Long2+1,environment.AF.2d$AF.Lat2+1,density=ifelse(is.na(environment.AF.2d$Long2),20,0))

title("E)",cex.main=3,adj=0)
title(main="Neutral",line=-15,cex.main=3)

par(op)
```
###### Fig 2. Projection of the species richness predicted by dispersal models on the map and comparison with the observed species distribution. Warmer colors represent areas with hiher species richness. (A) Observed species richness; (B) Predicted by the climatic variables in the logistic models; (B) Predicted by habitat quality in the logistic models; (D) Predicted by the Mid Domain model; (E) Predicted by the neutral model. Blank cells represent areas included in the neutral model but where actual data is not available.


####


  The similarity in species composition summarized by the first ordination axis was well fit for both the neutral, the Mid Domain, and the climatic models when comparing their explanatory power (Table 1). The mid domain model had the lowest MSE, and the mid domain and the neutral model had the lowest bias (Table 1). For the second ordination axis, all models had a poor explanatory power (R²<=15; Table 1). The lowest bias was obtained by the neutral model, and the lowest MSE by the habitat quality model. The lowest AICs were obtained by the neutral and mid domain models for both axes.
Habitat quality was a poor predictor of both ordination axes.

####

###### Table 2. AIC values comparing the 10 regression models tested for species composition. Specias composition was measured as the first (MC1) and second (MC2) axes of the principal component analysis summarizing the jaccard similarity matrix. MC1.1 and MC2.1: Environmental variables as predictors; MC1.2 and MC2.2: Environmental variables + Neutral as predictors; MC1.3 and MC2.3: Environmental variables + Mid Domain as predictors; MC1.4 and MC2.4: Neutral; MC1.5 and MC2.5: Mid Domain; MC1.6 and MC2.6: Environmental variables as predictors of residuals from Neutral; MC1.7 and MC2.7:  Environmental variables as predictors of residuals from Mid Domain; MR1.8 and MC2.8: Logistic models as predictors; MC1.9 and MC2.9: Logistic model + Neutral as predictors; MC1.10 and MC2.10: Logistic model + Mid Domain as predictors.

####

```{r Tab2_AICs composition, echo=FALSE, results='asis'}

npar=c(4,6,4,3,1,6,4,65,67,65,3,5,3,5,3,65,67,65)

logLik<-unlist(lapply(list(MC1.1,MC1.2,MC1.3,MC1.4,MC1.5,MC1.6,MC1.7,MC1.8,MC1.9,MC1.10,MC1.11,MC1.12,MC1.13,MC1.16,MC1.17,MC1.18,MC1.19,MC1.20,MC2.1,MC2.2,MC2.3,MC2.4,MC2.5,MC2.6,MC2.7,MC2.8,MC2.9,MC2.10,MC2.11,MC2.12,MC2.13,MC2.16,MC2.17,MC2.18,MC2.19,MC2.20),logLik))

rsquares<-unlist(lapply(list(MC1.1,MC1.2,MC1.3,MC1.4,MC1.5,MC1.6,MC1.7,MC1.8,MC1.9,MC1.10,MC1.11,MC1.12,MC1.13,MC1.16,MC1.17,MC1.18,MC1.19,MC1.20,MC2.1,MC2.2,MC2.3,MC2.4,MC2.5,MC2.6,MC2.7,MC2.8,MC2.9,MC2.10,MC2.11,MC2.12,MC2.13,MC2.16,MC2.17,MC2.18,MC2.19,MC2.20),function(x)cor(x$fitted.values+x$residuals,x$fitted.values)^2))

BIASsq<-rep(NA,36)
VAR<-rep(NA,36)

BIASsq[c(5,4,8,16,23,22,26,34)]<-c(MidD=s.bias.sq.MidD.c1,Neutral=s.bias.sq.neu.c1,s.bias.sq.logis.c1[c(24,3)],MidD=s.bias.sq.MidD.c2,Neutral=s.bias.sq.neu.c2,s.bias.sq.logis.c2[c(24,3)])
VAR[c(5,4,8,16,23,22,26,34)]<-c(MidD=s.var.MidD.c1,Neutral=s.var.neu.c1,s.var.logis.c1[c(24,3)],MidD=s.var.MidD.c2,Neutral=s.var.neu.c2,s.var.logis.c2[c(24,3)])

print(xtable(
  data.frame(modeln=strsplit("MC1.1,MC1.2,MC1.3,MC1.4,MC1.5,MC1.6,MC1.7,MC1.8,MC1.9,MC1.10,MC1.11,MC1.12,MC1.13,MC1.16,MC1.17,MC1.18,MC1.19,MC1.20,MC2.1,MC2.2,MC2.3,MC2.4,MC2.5,MC2.6,MC2.7,MC2.8,MC2.9,MC2.10,MC2.11,MC2.12,MC2.13,MC2.16,MC2.17,MC2.18,MC2.19,MC2.20",",")[[1]],Model=c("rawClim","rawClim+Neu","rawClim+Mid","Neutral","Mid domain","ResN~rawClim","ResN~rawClim","Cimatic","Climatic+Neu","Climatic+Mid","rawHab","rawHab+Neu","rawHab+Mid","ResN~rawHab","ResN~rawHab","Habitat","Habitat+Neu","Habitat+Mid"),logLik=logLik,npar=npar,AIC=-2*logLik+2*npar,rsquares=rsquares,BIASsq=BIASsq,VAR=VAR,MSE=BIASsq+VAR)[c(8,16,5,4,26,34,23,22),-1]
  ),type=table.type,html.table.attributes="border=1, bgcolor=#989898",comment=FALSE)

write.csv(  
data.frame(modeln=strsplit("MC1.1,MC1.2,MC1.3,MC1.4,MC1.5,MC1.6,MC1.7,MC1.8,MC1.9,MC1.10,MC1.11,MC1.12,MC1.13,MC1.16,MC1.17,MC1.18,MC1.19,MC1.20,MC2.1,MC2.2,MC2.3,MC2.4,MC2.5,MC2.6,MC2.7,MC2.8,MC2.9,MC2.10,MC2.11,MC2.12,MC2.13,MC2.16,MC2.17,MC2.18,MC2.19,MC2.20",",")[[1]],Model=c("rawClim","rawClim+Neu","rawClim+Mid","Neutral","Mid domain","ResN~rawClim","ResN~rawClim","Cimatic","Climatic+Neu","Climatic+Mid","rawHab","rawHab+Neu","rawHab+Mid","ResN~rawHab","ResN~rawHab","Habitat","Habitat+Neu","Habitat+Mid"),logLik=logLik,npar=npar,AIC=-2*logLik+2*npar,rsquares=rsquares,BIASsq=BIASsq,VAR=VAR,MSE=BIASsq+VAR)[c(8,16,5,4,26,34,23,22),-1]
,"Table_2.csv")



```

###

```{r Fig_3_Map_Composition_Mid_Domain_vs_Neutral,fig.width=18,fig.height=9,echo=FALSE,message=FALSE,results='hide',warning=FALSE}

par(mfrow=c(1,2))

plot(brazil)
rect(environment.2d$Long2-1,environment.2d$Lat2-1,environment.2d$Long2+1,environment.2d$Lat2+1,
     col=adjustcolor(color.select(environment.2d$pcoa.jac.1),alpha=.8))
title("A)",cex.main=3,adj=0)
title(main="Observed",line=-15,cex.main=3)

plot(brazil)
rect(environment.AF.2d$Long2-1,environment.AF.2d$Lat2-1,environment.AF.2d$Long2+1,environment.AF.2d$Lat2+1,
     col=adjustcolor(color.select(predict(MC1.8,newdata=decostand(environment.AF.2d,"standardize"))
),alpha=.8))
title("B)",cex.main=3,adj=0)
title(main="Climatic",line=-15,cex.main=3)

plot(brazil)
rect(environment.AF.2d$Long2-1,environment.AF.2d$Lat2-1,environment.AF.2d$Long2+1,environment.AF.2d$Lat2+1,
     col=adjustcolor(color.select(predict(MC1.18,newdata=decostand(environment.AF.2d,"standardize"))
),alpha=.8))
title("C)",cex.main=3,adj=0)
title(main="Habitat",line=-15,cex.main=3)


plot(brazil)
rect(environment.2d$Long2-1,environment.2d$Lat2-1,environment.2d$Long2+1,environment.2d$Lat2+1,
     col=adjustcolor(color.select(environment.2d$pcoa.MidD.jac.1),alpha=.8))
title("D)",cex.main=3,adj=0)
title(main="Mid Domain",line=-15,cex.main=3)

plot(brazil)
rect(environment.AF.2d$AF.Long2-1,environment.AF.2d$AF.Lat2-1,environment.AF.2d$AF.Long2+1,environment.AF.2d$AF.Lat2+1,
     col=adjustcolor(color.select(environment.AF.2d$pcoa.jac.neutral.total.1*(environment.AF.2d$rich*0+1),ref=environment.AF.2d$pcoa.jac.neutral.total.1*environment.AF.2d$Long2/environment.AF.2d$Long2),alpha=.8))

#rect(environment.AF.2d$AF.Long2-1,environment.AF.2d$AF.Lat2-1,environment.AF.2d$AF.Long2+1,environment.AF.2d$AF.Lat2+1,density=ifelse(is.na(environment.AF.2d$Long2),20,0))

title("E)",cex.main=3,adj=0)
title(main="Neutral",line=-15,cex.main=3)

par(op)
```
###### Fig 3. Projection of the species composition predicted by dispersal models on the map and comparison with the observed species distribution. The colors represent the similarity in species composition measured by the pairwise jaccard similarity index between sites summirized in one axis of a principal coordinates analysis (pcoa). Those grid cells with similar colors have a similar composition of species. (A) Observed species composition; (B) Species composition predicted by the climatic variables in the logistic models; (C) Species composition predicted by habitat quality in the logistic models; (D) Species composition predicted by the Mid Domain model; (E) Species composition predicted by the neutral model. Shadded grid cells represent areas included in the neutral model but where actual data is not available.

####


  The mantel test results showed a stronger climatic effect on species composition when grouping the data in grid cells (Table 3). The geographical distance was highly correlated with the species composition in both cases. Geographical distance was correlated with the species composition when the climatic effect was partialed out, but the correlation was stronger in the unconstrained model (Table 3). The similarity in species composition was also weakly associated with the climatic variables when controlling for geographical distance in the grouped data. Habitat quality was a poor predictor of species composition in all models (Table 3).

###### Table 3. Mantel and partial Mantel test results comparing the correlation of species similarity against geographical distance and environmental dissimilarity. The minus sign indicate partial results (Geo - Env: Geographical distance without the effect of environmenal dissimilarity).

####


```{r Table_3_Mantel and Partial Mantel results, echo=FALSE,results='asis'}

print(xtable(rbind("Local Geo"=man.geo.loc[c("statistic","signif")],
"Local Clim"=man.env.loc[c("statistic","signif")],
"Local Hab"=man.hab.loc[c("statistic","signif")],
"2d Geo"=man.geo.2d[c("statistic","signif")],
"2d Env"=man.env.2d[c("statistic","signif")],
"2d Hab"=man.hab.2d[c("statistic","signif")],
"Local Geo-Env"=pman.geo.loc[c("statistic","signif")],
"Local Env-Geo"=pman.env.loc[c("statistic","signif")],
"Local Hab-Geo"=pman.hab.loc[c("statistic","signif")],
"2d Geo-Env"=pman.geo.2d[c("statistic","signif")],
"2d Env-Geo"=pman.env.2d[c("statistic","signif")],
"2d Hab-Geo"=pman.env.2d[c("statistic","signif")])
),type=table.type,html.table.attributes="border=1, bgcolor=#989898",comment=FALSE)


write.csv(
rbind("Local Geo"=man.geo.loc[c("statistic","signif")],
"Local Clim"=man.env.loc[c("statistic","signif")],
"Local Hab"=man.hab.loc[c("statistic","signif")],
"2d Geo"=man.geo.2d[c("statistic","signif")],
"2d Env"=man.env.2d[c("statistic","signif")],
"2d Hab"=man.hab.2d[c("statistic","signif")],
"Local Geo-Env"=pman.geo.loc[c("statistic","signif")],
"Local Env-Geo"=pman.env.loc[c("statistic","signif")],
"Local Hab-Geo"=pman.hab.loc[c("statistic","signif")],
"2d Geo-Env"=pman.geo.2d[c("statistic","signif")],
"2d Env-Geo"=pman.env.2d[c("statistic","signif")],
"2d Hab-Geo"=pman.env.2d[c("statistic","signif")])
,"Table_3.csv")


```

###

Both neutral and Mid Domain models had very similar predictions for the distance-decay pattern in species similarity (Fig. 4). However, the decay predicted the dispersal models was much steeper in shorter distances than estimated by the glm model of species similarity against geographical distance (Fig. 4). The climatic variables predicted an almost linear decay in species similarity against geographical distance (Fig. 4).


```{r Fig_4_distance_decay_real_midDomain_and_neutral_mor, echo=FALSE,results='hide',warning=FALSE}

plot(geodist.2d,1-similarity.jac,ylim=c(0,1),pch=21,bg="dark grey",col=NULL,xlab="Geographical distance (arc Degrees)", ylab="Jaccard similarity",cex.lab=1.5)

points(geodist.2d,MS1.1$fitted.values,pch=21,bg=adjustcolor(3,alpha=.3),col=NULL) #Clim

points(geodist.2d,MS1.11$fitted.values,pch=21,bg=adjustcolor("#ee6e1a",alpha=.3),col=NULL) #Hab

points(geodist.2d,as.dist(morisita.AF.2d[environment.2d$matchin.AF.2d,environment.2d$matchin.AF.2d]),pch=21,bg=adjustcolor(4,alpha=.3),col=NULL)
points(geodist.2d,1-as.dist(similarity.MidD.mean),pch=21,bg=adjustcolor(2,alpha=.3),col=NULL)

lines(levels(factor(geodist.2d)),tapply(MS1.1$fitted.values,geodist.2d,mean),lwd=2,col=1)
lines(levels(factor(geodist.2d)),tapply(MS1.11$fitted.values,geodist.2d,mean),lwd=2,col="#ee6e1a")

lines(levels(factor(geodist.2d)),tapply(as.dist(morisita.AF.2d[environment.2d$matchin.AF.2d,environment.2d$matchin.AF.2d]),geodist.2d,mean),lwd=2,col=4)
lines(levels(factor(geodist.2d)),tapply(1-as.dist(similarity.MidD.mean),geodist.2d,mean),lwd=2,col=2)

lines(levels(factor(geodist.2d)),tapply(MS1.0$fitted.values,geodist.2d,mean),lwd=2,col=1,lty=2)

#Using the predictive r2 (wrong for glm)
#legend("topright",legend=c(paste("Logarithm",round(cor(similarity.jac,predict(MS1.0))^2,3)),  paste("Environment",round(cor(similarity.jac,predict(MS1.1))^2,3)),  paste("Neutral",round(cor(similarity.jac,predict(MS1.4))^2,3)),paste("Mid Domain",round(cor(similarity.jac,predict(MS1.5))^2,3))),title="R-squares:",col=c(1,1,4,2),lwd=2,lty=c(2,1,1,1),pch=c(NA,21,21,21),pt.bg=adjustcolor(c(1,3,4,2),alpha=.7),bty="n",pt.lwd=0,pt.cex=1.3)


#Using the McFaddens's r-square
legend("topright",legend=c(paste("Logarithm",round(1-(MS1.0$deviance/MS1.0$null.deviance),3)),  paste("Climatic",round(1-(MS1.1$deviance/MS1.0$null.deviance),3)), paste("Habitat",round(1-(MS1.11$deviance/MS1.11$null.deviance),3)) , paste("Neutral",round(cor(similarity.jac,predict(MS1.4))^2,3)),paste("Mid Domain",round(cor(similarity.jac,predict(MS1.5))^2,3))),title="R-squares:",col=c(1,1,"#ee6e1a",4,2),lwd=2,lty=c(2,1,1,1,1,1),pch=c(NA,21,21,21,21),pt.bg=adjustcolor(c(1,3,"#ee6e1a",4,2),alpha=.7),bty="n",pt.lwd=0,pt.cex=1.3)


#MS1.0$deviance
#sum(resid(MS1.0,"response")^2)
#deviance(MS1.5)/deviance(update(MS1.4,~1))
#MS1.0$null.deviance


# Plot the residuals of these models

```
###### Fig. 4. Distance-decay in species similarity using the Jaccard similarity index. The Mid Domain (red) and Neutral model (blue) have similar fit for the data, but the variance was much smaller than observed (grey). Habitat quality and the climatic variables did not predict the exponential decay with geographical distance.

####

----------------------------


```{r Fig_S1-Connectivity_map_26_and_56, echo=FALSE, fig.width=16,fig.height=8,results='hide',warning=FALSE}

par(mfrow=c(1,2))

plot(brazil,border="darkgrey")
rect(environment.2d$Long2-1,environment.2d$Lat2-1,environment.2d$Long2+1,environment.2d$Lat2+1,border=adjustcolor("darkgrey",alpha=1))

points(environment.2d$Long2,environment.2d$Lat2,pch=21,col=0,bg=2)

nnodes.2d<-nrow(environment.2d)

segments(matrix(environment.2d$Long2,nnodes.2d,nnodes.2d),
         matrix(environment.2d$Lat2,nnodes.2d,nnodes.2d),
         t(matrix(environment.2d$Long2,nnodes.2d,nnodes.2d)),
         t(matrix(environment.2d$Lat2,nnodes.2d,nnodes.2d)),col=connect.2d*2)

title("A)",cex.main=3,adj=0)

plot(brazil,border="darkgrey")
rect(environment.AF.2d$AF.Long2-1,environment.AF.2d$AF.Lat2-1,environment.AF.2d$AF.Long2+1,environment.AF.2d$AF.Lat2+1,border=adjustcolor("darkgrey",alpha=1))

points(environment.AF.2d$AF.Long2,environment.AF.2d$AF.Lat2,pch=21,col=0,bg=2)

nnodes.AF.2d<-nrow(environment.AF.2d)

segments(matrix(environment.AF.2d$AF.Long2,nnodes.AF.2d,nnodes.AF.2d),
         matrix(environment.AF.2d$AF.Lat2,nnodes.AF.2d,nnodes.AF.2d),
         t(matrix(environment.AF.2d$AF.Long2,nnodes.AF.2d,nnodes.AF.2d)),
         t(matrix(environment.AF.2d$AF.Lat2,nnodes.AF.2d,nnodes.AF.2d)),col=connect.AF.2d*2)

title("B)",cex.main=3,adj=0)

par(op)
```
###### Fig. S1. Map representing the connectivity of grid cells used to simulate the individual dispersal in the Mid Domain (A) and neutral (B) models.

####

```{r Fig_S2_rich_logis_in_the_map, echo=FALSE, message=FALSE,warning=FALSE,results='hide'}

attach(environment.2d)

par(mfrow=c(ceiling((length(rich.logis)+1)/ceiling(sqrt(1+length(rich.logis)))),ceiling(sqrt(1+length(rich.logis)))),mar=c(0,0,0,0))

plot(brazil)
rect(environment.2d$Long2-1,environment.2d$Lat2-1,environment.2d$Long2+1,environment.2d$Lat2+1,
     col=adjustcolor(color.select(environment.2d$rich,palette=Custom.Palette),alpha=.8))
title(main="Observed",line=-4)
title(main="A)",adj=0,line=-1)

for (i in glm.variables.2d){
  plot(brazil)
  title(main=i,line=-4)
  points(Long2,Lat2,pch=22,bg='darkgrey',col=0,cex=.5)
  rect(Long2-1,Lat2-1,Long2+1,Lat2+1,col=color.select(rich.logis[[paste("rich.logis.",i,sep="")]],palette=Custom.Palette))
  #plot(brazil,add=T)

  title(main=paste(LETTERS[match(i, glm.variables.2d)+1],")",sep=""),adj=0,line=-1)

  }

detach(environment.2d)

```
###### Fig S2. Projection of the species richness predicted by logistic models on the map and comparison with the observed species distribution. Warmer colors represent areas with hiher species richness. (A) Observed species richness; (B-Z) Predicted by logistic regressions of individual species against environmental gradients. 


####

```{r Fig_S3_jac_logis_in_the_map, echo=FALSE, message=FALSE,warning=FALSE,results='hide'}

attach(environment.AF.2d)

par(mfrow=c(ceiling((length(rich.logis)+1)/ceiling(sqrt(1+length(rich.logis)))),ceiling(sqrt(1+length(rich.logis)))),mar=c(0,0,0,0))

plot(brazil)
rect(environment.2d$Long2-1,environment.2d$Lat2-1,environment.2d$Long2+1,environment.2d$Lat2+1,
     col=adjustcolor(color.select(environment.2d$pcoa.jac.1),alpha=.8))
title(main="Observed",line=-4)
title(main="A)",adj=0,line=-1)

for (i in glm.variables.2d){
  plot(brazil)
  title(main=i,line=-4)
  points(Long2,Lat2,pch=22,bg='darkgrey',col=0,cex=.5)
rect(environment.AF.2d$Long2-1,environment.AF.2d$Lat2-1,environment.AF.2d$Long2+1,environment.AF.2d$Lat2+1,col=adjustcolor(color.select(environment.AF.2d[,paste("pcoa.logis.jac.",i,".1",sep="")]),alpha=.8))
  #plot(brazil,add=T)
  
    title(main=paste(LETTERS[match(i, glm.variables.2d)+1],")",sep=""),adj=0,line=-1)

  }

```
###### Fig S3. Projection of the species composition predicted by dispersal models on the map and comparison with the observed species distribution. The colors represent the similarity in species composition measured by the pairwise jaccard similarity index between sites summarized in one axis of a principal coordinates analysis (pcoa). Those grid cells with similar colors have a similar composition of species. (A) Observed species composition; (B-Z) Species composition predicted by logistic regressions of individual species against the environmental gradients.


####

```{r Fig_S4_plot_all_predictions_against_lat,message=FALSE,results='hide',echo=FALSE,warning=FALSE}

#par(mfrow=c(1,2))

plot(environment.2d$Lat2,decostand(environment.2d$pcoa.jac.1,'range'),bg="gold",pch=22,xlab="Latitude",ylab="Axis 1",cex.lab=1.5)

points(environment.2d$Lat2,decostand(environment.2d$pcoa.MidD.jac.1,'range'),bg=2,pch=23)

points((environment.AF.2d$AF.Lat2),decostand(environment.AF.2d$pcoa.mor.1,'range',na.rm=T),bg=4,pch=24)

#points((environment.AF.2d$AF.Lat2),decostand(environment.AF.2d$pcoa.mor.neutral.1,'range',na.rm=T),bg=1,pch=3,cex=2)

#plot.new()

legend("topright",c("Observed","MidD","Neutral"),pch=c(22,23,24,3),pt.bg=c("gold",2,4,3),bty="n",y.intersp=1.2,cex=1)

#plot(decostand(environment.AF.2d$pcoa.mor.1,'range',na.rm=T),decostand(environment.AF.2d$pcoa.mor.neutral.1,'range',na.rm=T),bg=1,pch=3,cex=2)
#plot(environment.AF.2d$pcoa.mor.1,environment.AF.2d$pcoa.mor.neutral.1,bg=1,pch=3,cex=2)

```
###### Fig S4. Change in species composition along the latitudinal gradient as predicted by the Neutral and Mid Domain models. The composition was measured by the Jaccard similarity index between all pairs of sites and summarized by the first axis of a Principal Coordinates Analysis (PCoA).


```{r Fig_S5_Residuals_similarity,fig.width=9,fig.height=6,echo=FALSE,message=FALSE,results='hide',warning=FALSE}

par(mfrow=c(2,3))

plot(geodist.2d,MS1.0$residuals,xlab="Geographical distance (arc Degrees)",ylab="Residuals",cex.lab=1.5,pch=21,bg=1)
lines(smooth.spline(geodist.2d,MS1.0$residuals))
abline(h=0,lwd=2,col=2)
title("A)",cex.main=1.5,adj=0)

plot(geodist.2d,MS1.1$residuals,xlab="Geographical distance (arc Degrees)",ylab="Residuals",cex.lab=1.5,pch=21,bg=1)
lines(smooth.spline(geodist.2d,MS1.1$residuals))
abline(h=0,lwd=2,col=2)
title("B)",cex.main=1.5,adj=0)

plot(geodist.2d,MS1.11$residuals,xlab="Geographical distance (arc Degrees)",ylab="Residuals",cex.lab=1.5,pch=21,bg=1)
lines(smooth.spline(geodist.2d,MS1.11$residuals))
abline(h=0,lwd=2,col=2)
title("C)",cex.main=1.5,adj=0)

plot(geodist.2d,MS1.4$residuals,xlab="Geographical distance (arc Degrees)",ylab="Residuals",cex.lab=1.5,pch=21,bg=1)
lines(smooth.spline(geodist.2d,MS1.4$residuals))
abline(h=0,lwd=2,col=2)
title("D)",cex.main=1.5,adj=0)

plot(geodist.2d,MS1.5$residuals,xlab="Geographical distance (arc Degrees)",ylab="Residuals",cex.lab=1.5,pch=21,bg=1)
lines(smooth.spline(geodist.2d,MS1.5$residuals))
abline(h=0,lwd=2,col=2)
title("E)",cex.main=1.5,adj=0)


```
###### Fig S5. Residual plots of the the fitted models using the pairwise Jaccard similarity as a response variable. The plots represent the models using (A) geographical distance; (B) environmental distance; (C) Neutral; and (D) Mid-Domain models as predictors. For A and B, the fitted model was a Generalized Linear Model with a log link and binomial distribution. For C and D, the graphs represent the deviations predicted by simulations (see data analysis for details).

###

```{r FigS6_residuals_regressions_richness,fig.width=6,fig.height=6,echo=FALSE,message=FALSE,results='hide',warning=FALSE}

par(mfrow=c(2,2))

plot(MR1.1$fitted.values,MR1.1$fitted.values+resid(MR1.1,"response"),xlab="Fitted Values",ylab="Observed",cex.lab=1.5,pch=21,bg=1,ylim=c(-1.6,2),xlim=c(-1.6,2))
abline(lm(MR1.1$fitted.values+resid(MR1.1,"response")~MR1.1$fitted.values))
abline(0,1,lwd=2,col=2)
title("A)",cex.main=1.5,adj=0)

plot(MR1.11$fitted.values,MR1.11$fitted.values+resid(MR1.11,"response"),xlab="Fitted Values",ylab="Observed",cex.lab=1.5,pch=21,bg=1,ylim=c(-1.6,2),xlim=c(-1.6,2))
abline(lm(MR1.11$fitted.values+resid(MR1.11,"response")~MR1.11$fitted.values))
abline(0,1,lwd=2,col=2)
title("B)",cex.main=1.5,adj=0)

plot(MR1.4$fitted.values,MR1.4$fitted.values+resid(MR1.4,"response"),xlab="Fitted Values",ylab="Observed",cex.lab=1.5,pch=21,bg=1,ylim=c(-1.6,2),xlim=c(-1.6,2))
abline(lm(MR1.4$fitted.values+resid(MR1.4,"response")~MR1.4$fitted.values))
abline(0,1,lwd=2,col=2)
title("C)",cex.main=1.5,adj=0)

plot(MR1.5$fitted.values,MR1.5$fitted.values+resid(MR1.5,"response"),xlab="Fitted Values",ylab="Observed",cex.lab=1.5,pch=21,bg=1,ylim=c(-1.6,2),xlim=c(-1.6,2))
abline(lm(MR1.5$fitted.values+resid(MR1.5,"response")~MR1.5$fitted.values))
abline(0,1,lwd=2,col=2)
title("D)",cex.main=1.5,adj=0)
```
###### Fig S6. Residual plots of the the fitted models using the pairwise Jaccard similarity as a response variable. The plots represent the models using (A) geographical distance; (B) environmental distance; (C) Neutral; and (D) Mid-Domain models as predictors. For A and B, the fitted model was a Generalized Linear Model with a log link and binomial distribution. For C and D, the graphs represent the deviations predicted by simulations (see data analysis for details).

###


```{r FigS7_residuals_regressions_composition,fig.width=6,fig.height=6,echo=FALSE,message=FALSE,results='hide',warning=FALSE}

par(mfrow=c(2,2))

plot(MC1.1$fitted.values,MC1.1$fitted.values+resid(MC1.1,"response"),xlab="Fitted Values",ylab="Observed",cex.lab=1.5,pch=21,bg=1,ylim=c(-1.6,1.9),xlim=c(-1.6,1.9))
abline(lm(MC1.1$fitted.values+resid(MC1.1,"response")~MC1.1$fitted.values))
abline(0,1,lwd=2,col=2)
title("A)",cex.main=1.5,adj=0)

plot(MC1.11$fitted.values,MC1.11$fitted.values+resid(MC1.11,"response"),xlab="Fitted Values",ylab="Observed",cex.lab=1.5,pch=21,bg=1,ylim=c(-1.6,1.9),xlim=c(-1.6,1.9))
abline(lm(MC1.11$fitted.values+resid(MC1.11,"response")~MC1.11$fitted.values))
abline(0,1,lwd=2,col=2)
title("B)",cex.main=1.5,adj=0)

plot(MC1.4$fitted.values,MC1.4$fitted.values+resid(MC1.4,"response"),xlab="Fitted Values",ylab="Observed",cex.lab=1.5,pch=21,bg=1,ylim=c(-1.6,1.9),xlim=c(-1.6,1.9))
abline(lm(MC1.4$fitted.values+resid(MC1.4,"response")~MC1.4$fitted.values))
abline(0,1,lwd=2,col=2)
title("C)",cex.main=1.5,adj=0)

plot(MC1.5$fitted.values,MC1.5$fitted.values+resid(MC1.5,"response"),xlab="Fitted Values",ylab="Observed",cex.lab=1.5,pch=21,bg=1,ylim=c(-1.6,1.9),xlim=c(-1.6,1.9))
abline(lm(MC1.5$fitted.values+resid(MC1.5,"response")~MC1.5$fitted.values))
abline(0,1,lwd=2,col=2)
title("D)",cex.main=1.5,adj=0)

```
###### Fig S7. Residual plots of the the fitted models using the pairwise Jaccard similarity as a response variable. The plots represent the models using (A) geographical distance; (B) environmental distance; (C) Neutral; and (D) Mid-Domain models as predictors. For A and B, the fitted model was a Generalized Linear Model with a log link and binomial distribution. For C and D, the graphs represent the deviations predicted by simulations (see data analysis for details).


####



###### Table S1. List of the sites, authors, etc. used in this manuscript

###

###### Table S2. Bias, Variance and Mean Square Error of the Mid Domain, Neutral and Logistic simulation models for species richness. The Mean Square Error is the sum of the Bias and Variance.

####

``` {r Table_S2_MSE-rich_Results,echo=FALSE,results='asis'}

print(xtable(data.frame(BIASsq=c(MidD=s.bias.sq.MidD,Neutral=s.bias.sq.neutral,s.bias.sq.logis),
VAR=c(MidD=s.var.MidD,Neutral=s.var.neutral,s.var.logis),
sMSE=c(MidD=s.mse.MidD,Neutral=s.mse.neutral,s.mse.logis))[,]
),type=table.type,html.table.attributes="border=1, bgcolor=#989898",comment=FALSE)

write.csv(data.frame(BIASsq=c(MidD=s.bias.sq.MidD,Neutral=s.bias.sq.neutral,s.bias.sq.logis),
VAR=c(MidD=s.var.MidD,Neutral=s.var.neutral,s.var.logis),
sMSE=c(MidD=s.mse.MidD,Neutral=s.mse.neutral,s.mse.logis))[,]
,"Table_S2.csv")


```

###

###### Table S3. Bias, Variance and Mean Square Error of the Mid Domain, Neutral and Logistic simulation models for the jaccard pairwise similarity. The Mean Square Error is the sum of the Bias and Variance.

```{r Table_S3_MSE-comp_Results,echo=FALSE,results='asis'}

print(xtable(data.frame(BIASsq=c(MidD=s.bias.sq.MidD.jac,Neutral=s.bias.sq.neu.jac,s.bias.sq.logis.jac),
VAR=c(MidD=s.var.MidD.jac,Neutral=s.var.neu.jac,s.var.logis.jac),
sMSE=c(MidD=s.mse.MidD.jac,Neutral=s.mse.neu.jac,s.mse.logis.jac))[,]
),type=table.type,html.table.attributes="border=1, bgcolor=#989898",comment=FALSE)

write.csv(data.frame(BIASsq=c(MidD=s.bias.sq.MidD.jac,Neutral=s.bias.sq.neu.jac,s.bias.sq.logis.jac),
VAR=c(MidD=s.var.MidD.jac,Neutral=s.var.neu.jac,s.var.logis.jac),
sMSE=c(MidD=s.mse.MidD.jac,Neutral=s.mse.neu.jac,s.mse.logis.jac))[,]
,"Table_S3.csv")


```

###

### Discussion



### Acknowledgements


### Cited bibliography



----------------------------

```{r detach_data, echo=FALSE,results='hide',warning=FALSE,message=FALSE}

detach(mammal.data)

```


```{r extracting_R_chunks, echo=FALSE, message=FALSE,warning=FALSE,results='hide'}

purl("All_analysis_simplified.Rmd")

```


```{r knit2html, echo=FALSE, eval=FALSE,results='hide'}

library(knitr)
library(rmarkdown)

knit("All_analysis_simplified.Rmd")
render("All_analysis_simplified.md","all")
render("All_analysis_simplified.md","pdf_document")
render("All_analysis_simplified.md","word_document")

```
